[
    {
        "identifier": "assembling_gift_baskets_0_Beechwood_0_int_0_2021-10-26_12-46-37",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem assembling_gift_baskets_0)\n    (:domain igibson)\n\n    (:objects\n     \tbasket.n.01_1 basket.n.01_2 basket.n.01_3 basket.n.01_4 - basket.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tcandle.n.01_1 candle.n.01_2 candle.n.01_3 candle.n.01_4 - candle.n.01\n    \tcookie.n.01_1 cookie.n.01_2 cookie.n.01_3 cookie.n.01_4 - cookie.n.01\n    \tcheese.n.01_1 cheese.n.01_2 cheese.n.01_3 cheese.n.01_4 - cheese.n.01\n    \tbow.n.08_1 bow.n.08_2 bow.n.08_3 bow.n.08_4 - bow.n.08\n        table.n.02_1 table.n.02_2 - table.n.02\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor basket.n.01_1 floor.n.01_1) \n        (onfloor basket.n.01_2 floor.n.01_1) \n        (onfloor basket.n.01_3 floor.n.01_1) \n        (onfloor basket.n.01_4 floor.n.01_1) \n        (ontop candle.n.01_1 table.n.02_1) \n        (ontop candle.n.01_2 table.n.02_1) \n        (ontop candle.n.01_3 table.n.02_1) \n        (ontop candle.n.01_4 table.n.02_1) \n        (ontop cookie.n.01_1 table.n.02_1) \n        (ontop cookie.n.01_2 table.n.02_1) \n        (ontop cookie.n.01_3 table.n.02_1) \n        (ontop cookie.n.01_4 table.n.02_1) \n        (ontop cheese.n.01_1 table.n.02_2) \n        (ontop cheese.n.01_2 table.n.02_2) \n        (ontop cheese.n.01_3 table.n.02_2) \n        (ontop cheese.n.01_4 table.n.02_2) \n        (ontop bow.n.08_1 table.n.02_2) \n        (ontop bow.n.08_2 table.n.02_2) \n        (ontop bow.n.08_3 table.n.02_2) \n        (ontop bow.n.08_4 table.n.02_2) \n        (inroom floor.n.01_1 living_room) \n        (inroom table.n.02_1 living_room) \n        (inroom table.n.02_2 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forpairs \n                (?basket.n.01 - basket.n.01) \n                (?candle.n.01 - candle.n.01) \n                (inside ?candle.n.01 ?basket.n.01)\n            ) \n            (forpairs \n                (?basket.n.01 - basket.n.01) \n                (?cheese.n.01 - cheese.n.01) \n                (inside ?cheese.n.01 ?basket.n.01)\n            ) \n            (forpairs \n                (?basket.n.01 - basket.n.01) \n                (?cookie.n.01 - cookie.n.01) \n                (inside ?cookie.n.01 ?basket.n.01)\n            ) \n            (forpairs \n                (?basket.n.01 - basket.n.01) \n                (?bow.n.08 - bow.n.08) \n                (inside ?bow.n.08 ?basket.n.01)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "bottling_fruit_0_Wainscott_0_int_0_2021-05-24_19-46-46",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem bottling_fruit_0)\n    (:domain igibson)\n\n    (:objects\n     \tstrawberry.n.01_1 - strawberry.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tpeach.n.03_1 - peach.n.03\n    \tcountertop.n.01_1 - countertop.n.01\n    \tjar.n.01_1 jar.n.01_2 - jar.n.01\n        carving_knife.n.01_1 - carving_knife.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (inside strawberry.n.01_1 electric_refrigerator.n.01_1) \n        (inside peach.n.03_1 electric_refrigerator.n.01_1) \n        (not \n            (sliced strawberry.n.01_1)\n        ) \n        (not \n            (sliced peach.n.03_1)\n        ) \n        (ontop jar.n.01_1 countertop.n.01_1) \n        (ontop jar.n.01_2 countertop.n.01_1) \n        (ontop carving_knife.n.01_1 countertop.n.01_1) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (exists \n                (?jar.n.01 - jar.n.01) \n                (and \n                    (inside ?strawberry.n.01_1 ?jar.n.01) \n                    (not \n                        (inside ?peach.n.03_1 ?jar.n.01)\n                    )\n                )\n            ) \n            (exists \n                (?jar.n.01 - jar.n.01) \n                (and \n                    (inside ?peach.n.03_1 ?jar.n.01) \n                    (not \n                        (inside ?strawberry.n.01_1 ?jar.n.01)\n                    )\n                )\n            ) \n            (forall \n                (?jar.n.01 - jar.n.01) \n                (not \n                    (open ?jar.n.01)\n                )\n            ) \n            (sliced strawberry.n.01_1) \n            (sliced peach.n.03_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action slice)\n:parameters (?obj - object ?knife - carving_knife.n.01 ?board - countertop.n.01 ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "boxing_books_up_for_storage_0_Benevolence_1_int_0_2021-09-10_15-35-47",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem boxing_books_up_for_storage_0)\n    (:domain igibson)\n\n    (:objects\n     \tbook.n.02_1 book.n.02_2 book.n.02_3 book.n.02_4 book.n.02_5 book.n.02_6 book.n.02_7 - book.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tshelf.n.01_1 - shelf.n.01\n    \tcarton.n.02_1 - carton.n.02\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor book.n.02_1 floor.n.01_1) \n        (onfloor book.n.02_2 floor.n.01_1) \n        (onfloor book.n.02_3 floor.n.01_1) \n        (onfloor book.n.02_4 floor.n.01_1) \n        (onfloor book.n.02_5 floor.n.01_1) \n        (ontop book.n.02_6 shelf.n.01_1) \n        (ontop book.n.02_7 shelf.n.01_1) \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom shelf.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?book.n.02 - book.n.02) \n                (inside ?book.n.02 ?carton.n.02_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "bringing_in_wood_0_Benevolence_1_int_0_2021-09-15_18-42-25",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem bringing_in_wood_0)\n    (:domain igibson)\n\n    (:objects\n        plywood.n.01_1 plywood.n.01_2 plywood.n.01_3 - plywood.n.01\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor plywood.n.01_1 floor.n.01_1) \n        (onfloor plywood.n.01_2 floor.n.01_1) \n        (onfloor plywood.n.01_3 floor.n.01_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom floor.n.01_2 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?plywood.n.01 - plywood.n.01) \n                (onfloor ?plywood.n.01 ?floor.n.01_2)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "brushing_lint_off_clothing_0_Pomaria_2_int_0_2021-06-04_17-41-56",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem brushing_lint_off_clothing_0)\n    (:domain igibson)\n\n    (:objects\n     \tsweater.n.01_1 sweater.n.01_2 sweater.n.01_3 sweater.n.01_4 - sweater.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tbed.n.01_1 - bed.n.01\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor sweater.n.01_1 floor.n.01_1) \n        (onfloor sweater.n.01_2 floor.n.01_1) \n        (ontop sweater.n.01_3 bed.n.01_1) \n        (ontop sweater.n.01_4 bed.n.01_1) \n        (dusty sweater.n.01_1) \n        (dusty sweater.n.01_2) \n        (dusty sweater.n.01_3) \n        (dusty sweater.n.01_4) \n        (onfloor scrub_brush.n.01_1 floor.n.01_1) \n        (not \n            (dusty scrub_brush.n.01_1)\n        ) \n        (inroom floor.n.01_1 bedroom) \n        (inroom bed.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?sweater.n.01 - sweater.n.01) \n                (not \n                    (dusty ?sweater.n.01)\n                )\n            ) \n            (forall \n                (?sweater.n.01 - sweater.n.01) \n                (ontop ?sweater.n.01 ?bed.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "chopping_vegetables_0_Rs_int_0_2021-05-25_22-01-16",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem chopping_vegetables_0)\n    (:domain igibson)\n\n    (:objects\n        tomato.n.01_1 tomato.n.01_2 - tomato.n.01\n        mushroom.n.05_1 mushroom.n.05_2 - mushroom.n.05\n        chestnut.n.03_1 chestnut.n.03_2 - chestnut.n.03\n        countertop.n.01_1 - countertop.n.01\n        vidalia_onion.n.01_1 vidalia_onion.n.01_2 - vidalia_onion.n.01\n        electric_refrigerator.n.01_1 - electric_refrigerator.n.01\n        knife.n.01_1 - knife.n.01\n        dish.n.01_1 dish.n.01_2 - dish.n.01\n        cabinet.n.01_1 - cabinet.n.01\n        sink.n.01_1 - sink.n.01\n        floor.n.01_1 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop tomato.n.01_1 countertop.n.01_1) \n        (ontop tomato.n.01_2 countertop.n.01_1) \n        (ontop mushroom.n.05_1 countertop.n.01_1) \n        (ontop mushroom.n.05_2 countertop.n.01_1) \n        (ontop chestnut.n.03_1 countertop.n.01_1) \n        (ontop chestnut.n.03_2 countertop.n.01_1) \n        (inside vidalia_onion.n.01_1 electric_refrigerator.n.01_1) \n        (inside vidalia_onion.n.01_2 electric_refrigerator.n.01_1) \n        (ontop knife.n.01_1 countertop.n.01_1) \n        (inside dish.n.01_1 cabinet.n.01_1) \n        (inside dish.n.01_2 cabinet.n.01_1) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?tomato.n.01 - tomato.n.01) \n                (and \n                    (exists \n                        (?dish.n.01 - dish.n.01) \n                        (inside ?tomato.n.01 ?dish.n.01)\n                    ) \n                    (sliced ?tomato.n.01)\n                )\n            ) \n            (forall \n                (?mushroom.n.05 - mushroom.n.05) \n                (and \n                    (exists \n                        (?dish.n.01 - dish.n.01) \n                        (inside ?mushroom.n.05 ?dish.n.01)\n                    ) \n                    (sliced ?mushroom.n.05)\n                )\n            ) \n            (forall \n                (?chestnut.n.03 - chestnut.n.03) \n                (and \n                    (exists \n                        (?dish.n.01 - dish.n.01) \n                        (inside ?chestnut.n.03 ?dish.n.01)\n                    ) \n                    (sliced ?chestnut.n.03)\n                )\n            ) \n            (forall \n                (?vidalia_onion.n.01 - vidalia_onion.n.01) \n                (and \n                    (exists \n                        (?dish.n.01 - dish.n.01) \n                        (inside ?vidalia_onion.n.01 ?dish.n.01)\n                    ) \n                    (sliced ?vidalia_onion.n.01)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action slice)\n:parameters (?obj - object ?knife - carving_knife.n.01 ?board - countertop.n.01 ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_a_car_0_Ihlen_0_int_0_2021-09-11_16-37-11",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_a_car_0)\n    (:domain igibson)\n\n    (:objects\n     \tcar.n.01_1 - car.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tshelf.n.01_1 - shelf.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \tbucket.n.01_1 - bucket.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor car.n.01_1 floor.n.01_1) \n        (ontop rag.n.01_1 shelf.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (ontop soap.n.01_1 shelf.n.01_1) \n        (dusty car.n.01_1) \n        (onfloor bucket.n.01_1 floor.n.01_1) \n        (inroom floor.n.01_1 garage) \n        (inroom sink.n.01_1 bathroom) \n        (inroom shelf.n.01_1 garage) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?car.n.01_1)\n            ) \n            (inside ?soap.n.01_1 ?bucket.n.01_1) \n            (inside ?rag.n.01_1 ?bucket.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_barbecue_grill_0_Ihlen_0_int_0_2021-09-10_16-02-39",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_barbecue_grill_0)\n    (:domain igibson)\n\n    (:objects\n     \tgrill.n.02_1 - grill.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tbucket.n.01_1 - bucket.n.01\n        table.n.02_1 - table.n.02\n        sink.n.01_1 - sink.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor grill.n.02_1 floor.n.01_1) \n        (stained grill.n.02_1) \n        (dusty grill.n.02_1) \n        (ontop bucket.n.01_1 table.n.02_1) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom floor.n.01_1 garage) \n        (inroom table.n.02_1 storage_room) \n        (inroom sink.n.01_1 storage_room)\n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?grill.n.02_1)\n            ) \n            (not \n                (dusty ?grill.n.02_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_bathrooms_0_Benevolence_0_int_1_2021-06-12_19-33-28",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_bathrooms_0)\n    (:domain igibson)\n\n    (:objects\n        sink.n.01_1 - sink.n.01\n        bathtub.n.01_1 - bathtub.n.01\n        toilet.n.02_1 - toilet.n.02\n        floor.n.01_1 - floor.n.01\n        bucket.n.01_1 - bucket.n.01\n        soap.n.01_1 - soap.n.01\n        brush.n.02_1 - brush.n.02\n        rag.n.01_1 - rag.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (stained sink.n.01_1) \n        (stained bathtub.n.01_1) \n        (stained toilet.n.02_1) \n        (stained floor.n.01_1) \n        (inside soap.n.01_1 sink.n.01_1) \n        (inside brush.n.02_1 bathtub.n.01_1) \n        (onfloor bucket.n.01_1 floor.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (onfloor rag.n.01_1 floor.n.01_1) \n        (onfloor agent.n.01_1 floor.n.01_1) \n        (inroom floor.n.01_1 bathroom) \n        (inroom toilet.n.02_1 bathroom) \n        (inroom sink.n.01_1 bathroom) \n        (inroom bathtub.n.01_1 bathroom)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?toilet.n.02_1)\n            ) \n            (not \n                (stained ?bathtub.n.01_1)\n            ) \n            (not \n                (stained ?sink.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_1)\n            ) \n            (and \n                (soaked ?rag.n.01_1) \n                (inside ?rag.n.01_1 ?bucket.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_bathtub_0_Pomaria_0_int_0_2021-09-10_16-22-10",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_bathtub_0)\n    (:domain igibson)\n\n    (:objects\n        sink.n.01_1 - sink.n.01\n     \tbathtub.n.01_1 - bathtub.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tbucket.n.01_1 - bucket.n.01\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (stained bathtub.n.01_1) \n        (onfloor soap.n.01_1 floor.n.01_1) \n        (onfloor bucket.n.01_1 floor.n.01_1) \n        (inside scrub_brush.n.01_1 bathtub.n.01_1) \n        (inroom floor.n.01_1 bathroom) \n        (inroom bathtub.n.01_1 bathroom) \n        (inroom sink.n.01_1 bathroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?bathtub.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_bedroom_0_Benevolence_2_int_0_2021-06-06_18-10-59",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_bedroom_0)\n    (:domain igibson)\n\n    (:objects\n        floor.n.01_1 - floor.n.01\n        apparel.n.01_1 apparel.n.01_2 - apparel.n.01\n        bed.n.01_1 - bed.n.01\n        jewelry.n.01_1 - jewelry.n.01\n        perfume.n.02_1 - perfume.n.02\n        painting.n.01_1 - painting.n.01\n        vacuum.n.04_1 - vacuum.n.04\n        hand_towel.n.01_1 - hand_towel.n.01\n        sheet.n.03_1 - sheet.n.03\n        cabinet.n.01_1 cabinet.n.01_2 - cabinet.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty cabinet.n.01_1) \n        (dusty cabinet.n.01_2) \n        (ontop apparel.n.01_1 bed.n.01_1) \n        (ontop apparel.n.01_2 bed.n.01_1) \n        (onfloor jewelry.n.01_1 floor.n.01_1) \n        (onfloor perfume.n.02_1 floor.n.01_1) \n        (ontop painting.n.01_1 bed.n.01_1) \n        (not \n            (dusty vacuum.n.04_1)\n        ) \n        (onfloor vacuum.n.04_1 floor.n.01_1) \n        (onfloor hand_towel.n.01_1 floor.n.01_1)\n        (onfloor sheet.n.03_1 floor.n.01_1) \n        (inroom floor.n.01_1 bedroom) \n        (inroom bed.n.01_1 bedroom) \n        (inroom cabinet.n.01_1 bedroom) \n        (inroom cabinet.n.01_2 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?apparel.n.01 - apparel.n.01) \n                (exists \n                    (?cabinet.n.01 - cabinet.n.01) \n                    (inside ?apparel.n.01 ?cabinet.n.01)\n                )\n            ) \n            (and \n                (inside ?jewelry.n.01_1 ?cabinet.n.01_1) \n                (inside ?perfume.n.02_1 ?cabinet.n.01_1)\n            ) \n            (ontop ?sheet.n.03_1 ?bed.n.01_1) \n            (forall \n                (?cabinet.n.01 - cabinet.n.01) \n                (not \n                    (dusty ?cabinet.n.01)\n                )\n            ) \n            (nextto ?vacuum.n.04_1 ?bed.n.01_1) \n            (ontop ?painting.n.01_1 ?sheet.n.03_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_vacuum)\n:parameters (?vacuum - vacuum.n.04 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_carpets_0_Wainscott_1_int_0_2021-09-11_01-12-41",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_carpets_0)\n    (:domain igibson)\n\n    (:objects\n     \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n        hand_towel.n.01_1 - hand_towel.n.01\n    \tshampoo.n.01_1 - shampoo.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \twasher.n.03_1 - washer.n.03\n    \tdryer.n.01_1 - dryer.n.01\n    \tdoor.n.01_1 - door.n.01\n        sink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (stained floor.n.01_1) \n        (onfloor hand_towel.n.01_1 floor.n.01_2)\n        (inside shampoo.n.01_1 cabinet.n.01_1) \n        (inroom floor.n.01_1 corridor) \n        (inroom floor.n.01_2 utility_room) \n        (inroom washer.n.03_1 utility_room) \n        (inroom dryer.n.01_1 utility_room) \n        (inroom door.n.01_1 corridor) \n        (inroom cabinet.n.01_1 utility_room) \n        (inroom sink.n.01_1 utility_room)\n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?floor.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_closet_0_Beechwood_1_int_0_2021-10-25_19-50-32",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_closet_0)\n    (:domain igibson)\n\n    (:objects\n     \tshelf.n.01_1 - shelf.n.01\n    \tcabinet.n.01_1 cabinet.n.01_2 cabinet.n.01_3 - cabinet.n.01\n    \tjewelry.n.01_1 jewelry.n.01_2 - jewelry.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \that.n.01_1 - hat.n.01\n    \tsandal.n.01_1 sandal.n.01_2 - sandal.n.01\n    \tumbrella.n.01_1 - umbrella.n.01\n    \ttowel.n.01_1 - towel.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty shelf.n.01_1) \n        (dusty cabinet.n.01_3) \n        (onfloor jewelry.n.01_1 floor.n.01_1) \n        (onfloor jewelry.n.01_2 floor.n.01_1) \n        (dusty floor.n.01_1) \n        (onfloor hat.n.01_1 floor.n.01_1) \n        (onfloor sandal.n.01_1 floor.n.01_1) \n        (onfloor sandal.n.01_2 floor.n.01_1) \n        (onfloor umbrella.n.01_1 floor.n.01_1) \n        (inside towel.n.01_1 cabinet.n.01_1) \n        (inroom cabinet.n.01_1 bedroom) \n        (inroom cabinet.n.01_2 bedroom) \n        (inroom cabinet.n.01_3 closet) \n        (inroom shelf.n.01_1 closet) \n        (inroom floor.n.01_1 closet) \n        (inroom floor.n.01_2 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?jewelry.n.01 - jewelry.n.01) \n                (inside ?jewelry.n.01 ?cabinet.n.01_3)\n            ) \n            (not \n                (inside ?umbrella.n.01_1 ?cabinet.n.01_3)\n            ) \n            (or \n                (inside ?hat.n.01_1 ?cabinet.n.01_1) \n                (ontop ?hat.n.01_1 ?shelf.n.01_1)\n            ) \n            (forall \n                (?sandal.n.01 - sandal.n.01) \n                (and \n                    (nextto ?sandal.n.01 ?shelf.n.01_1) \n                    (onfloor ?sandal.n.01 ?floor.n.01_1)\n                )\n            ) \n            (not \n                (dusty ?cabinet.n.01_3)\n            ) \n            (not \n                (dusty ?shelf.n.01_1)\n            ) \n            (not \n                (dusty ?floor.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object ?obj3 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_cupboards_0_Wainscott_1_int_1_2021-08-25_16-40-44",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_cupboards_0)\n    (:domain igibson)\n\n    (:objects\n     \tbook.n.02_1 book.n.02_2 book.n.02_3 - book.n.02\n    \tcabinet.n.01_1 cabinet.n.01_2 cabinet.n.01_3 - cabinet.n.01\n    \tpen.n.01_1 - pen.n.01\n    \tmarker.n.03_1 marker.n.03_2 - marker.n.03\n    \tscrewdriver.n.01_1 - screwdriver.n.01\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n    \trag.n.01_1 - rag.n.01\n    \tcleansing_agent.n.01_1 - cleansing_agent.n.01\n    \tbin.n.01_1 - bin.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tbucket.n.01_1 - bucket.n.01\n        bed.n.01_1 - bed.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (inside book.n.02_1 cabinet.n.01_1) \n        (inside book.n.02_2 cabinet.n.01_2) \n        (inside book.n.02_3 cabinet.n.01_2) \n        (inside pen.n.01_1 cabinet.n.01_1) \n        (inside marker.n.03_1 cabinet.n.01_2) \n        (inside marker.n.03_2 cabinet.n.01_2) \n        (inside screwdriver.n.01_1 cabinet.n.01_3) \n        (inside scrub_brush.n.01_1 cabinet.n.01_1) \n        (inside rag.n.01_1 cabinet.n.01_1) \n        (ontop cleansing_agent.n.01_1 bed.n.01_1) \n        (onfloor bin.n.01_1 floor.n.01_1) \n        (ontop bucket.n.01_1 bed.n.01_1) \n        (dusty cabinet.n.01_1) \n        (dusty cabinet.n.01_2) \n        (inroom cabinet.n.01_1 bedroom) \n        (inroom cabinet.n.01_2 bedroom) \n        (inroom cabinet.n.01_3 bedroom) \n        (inroom floor.n.01_1 bedroom) \n        (inroom bed.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?cabinet.n.01 - cabinet.n.01) \n                (not \n                    (dusty ?cabinet.n.01)\n                )\n            ) \n            (forall \n                (?book.n.02 - book.n.02) \n                (forall \n                    (?cabinet.n.01 - cabinet.n.01) \n                    (not \n                        (inside ?book.n.02 ?cabinet.n.01)\n                    )\n                )\n            )  \n            (inside ?screwdriver.n.01_1 ?bin.n.01_1) \n            (forall \n                (?marker.n.03 - marker.n.03) \n                (inside ?marker.n.03 ?bucket.n.01_1)\n            ) \n            (inside ?pen.n.01_1 ?bucket.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_floors_0_Merom_0_int_1_2021-06-23_16-12-28",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_floors_0)\n    (:domain igibson)\n\n    (:objects\n     \tfloor.n.01_1 - floor.n.01\n    \tbroom.n.01_1 - broom.n.01\n    \tdustpan.n.02_1 - dustpan.n.02\n    \tcleansing_agent.n.01_1 - cleansing_agent.n.01\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n    \tdoor.n.01_1 - door.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_1) \n        (onfloor broom.n.01_1 floor.n.01_1) \n        (onfloor dustpan.n.02_1 floor.n.01_1) \n        (onfloor cleansing_agent.n.01_1 floor.n.01_1) \n        (onfloor scrub_brush.n.01_1 floor.n.01_1) \n        (inroom floor.n.01_1 bathroom) \n        (inroom door.n.01_1 bathroom) \n        (inroom sink.n.01_1 bathroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?floor.n.01_1)\n            ) \n            (not \n                (dusty ?floor.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_freezer_0_Pomaria_1_int_0_2021-10-26_12-59-25",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_freezer_0)\n    (:domain igibson)\n\n    (:objects\n     \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tfood.n.01_1 food.n.01_2 food.n.01_3 - food.n.01\n    \tcleansing_agent.n.01_1 - cleansing_agent.n.01\n    \ttable.n.02_1 - table.n.02\n    \ttowel.n.01_1 - towel.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \tstove.n.01_1 - stove.n.01\n    \tdoor.n.01_1 - door.n.01\n    \tchair.n.01_1 - chair.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (stained electric_refrigerator.n.01_1) \n        (inside food.n.01_1 electric_refrigerator.n.01_1) \n        (inside food.n.01_2 electric_refrigerator.n.01_1) \n        (inside food.n.01_3 electric_refrigerator.n.01_1) \n        (ontop cleansing_agent.n.01_1 table.n.02_1) \n        (ontop towel.n.01_1 table.n.02_1) \n        (inroom floor.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom stove.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom door.n.01_1 kitchen) \n        (inroom table.n.02_1 kitchen) \n        (inroom chair.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?electric_refrigerator.n.01_1)\n            ) \n            (forall \n                (?food.n.01 - food.n.01) \n                (not \n                    (inside ?food.n.01 ?electric_refrigerator.n.01_1)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_garage_0_Ihlen_0_int_0_2021-08-24_17-40-48",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_garage_0)\n    (:domain igibson)\n\n    (:objects\n     \tbox.n.01_1 - box.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \tnewspaper.n.03_1 newspaper.n.03_2 - newspaper.n.03\n    \tbottle.n.01_1 bottle.n.01_2 - bottle.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tbroom.n.01_1 - broom.n.01\n    \trag.n.01_1 - rag.n.01\n    \ttable.n.02_1 - table.n.02\n    \tbin.n.01_1 - bin.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tshelf.n.01_1 - shelf.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor box.n.01_1 floor.n.01_1) \n        (onfloor newspaper.n.03_1 floor.n.01_1) \n        (onfloor newspaper.n.03_2 floor.n.01_1) \n        (onfloor bottle.n.01_1 floor.n.01_1) \n        (onfloor bottle.n.01_2 floor.n.01_1) \n        (dusty floor.n.01_1) \n        (stained floor.n.01_1) \n        (dusty cabinet.n.01_1) \n        (onfloor broom.n.01_1 floor.n.01_1) \n        (ontop rag.n.01_1 table.n.02_1) \n        (onfloor bin.n.01_1 floor.n.01_1) \n        (inroom floor.n.01_1 garage) \n        (inroom cabinet.n.01_1 garage) \n        (inroom sink.n.01_1 storage_room) \n        (inroom shelf.n.01_1 storage_room) \n        (inroom table.n.02_1 storage_room) \n        (inroom floor.n.01_2 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (dusty ?cabinet.n.01_1)\n            ) \n            (not \n                (stained ?cabinet.n.01_1)\n            ) \n            (forall \n                (?newspaper.n.03 - newspaper.n.03) \n                (or \n                    (inside ?newspaper.n.03 ?bin.n.01_1) \n                    (not \n                        (onfloor ?newspaper.n.03 ?floor.n.01_1)\n                    )\n                )\n            ) \n            (forall \n                (?bottle.n.01 - bottle.n.01) \n                (ontop ?bottle.n.01 ?table.n.02_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_high_chair_0_Wainscott_0_int_0_2021-06-05_18-03-15",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_high_chair_0)\n    (:domain igibson)\n\n    (:objects\n        highchair.n.01_1 - highchair.n.01\n        piece_of_cloth.n.01_1 - piece_of_cloth.n.01\n        cabinet.n.01_1 - cabinet.n.01\n        sink.n.01_1 - sink.n.01\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty highchair.n.01_1) \n        (inside piece_of_cloth.n.01_1 cabinet.n.01_1) \n        (onfloor highchair.n.01_1 floor.n.01_2) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom floor.n.01_2 dining_room) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?highchair.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_cloth)\n:parameters (?rag - piece_of_cloth.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_kitchen_cupboard_0_Pomaria_1_int_0_2021-10-26_13-05-36",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_kitchen_cupboard_0)\n    (:domain igibson)\n\n    (:objects\n     \tcabinet.n.01_1 cabinet.n.01_2 - cabinet.n.01\n        countertop.n.01_1 - countertop.n.01\n    \tpiece_of_cloth.n.01_1 - piece_of_cloth.n.01\n    \tcleansing_agent.n.01_1 - cleansing_agent.n.01\n    \tbowl.n.01_1 bowl.n.01_2 - bowl.n.01\n    \tcup.n.01_1 cup.n.01_2 - cup.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty cabinet.n.01_1) \n        (dusty cabinet.n.01_2) \n        (ontop piece_of_cloth.n.01_1 countertop.n.01_1) \n        (ontop cleansing_agent.n.01_1 countertop.n.01_1) \n        (inside bowl.n.01_2 cabinet.n.01_2) \n        (inside cup.n.01_1 cabinet.n.01_2) \n        (inside cup.n.01_2 cabinet.n.01_1) \n        (ontop bowl.n.01_1 countertop.n.01_1) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom cabinet.n.01_2 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?cabinet.n.01 - cabinet.n.01) \n                (not \n                    (dusty ?cabinet.n.01)\n                )\n            ) \n            (exists \n                (?cabinet.n.01 - cabinet.n.01) \n                (forall \n                    (?bowl.n.01 - bowl.n.01) \n                    (and \n                        (inside ?bowl.n.01 ?cabinet.n.01) \n                        (not \n                            (inside ?cup.n.01_1 ?cabinet.n.01)\n                        )\n                    )\n                )\n            ) \n            (exists \n                (?cabinet.n.01 - cabinet.n.01) \n                (forall \n                    (?cup.n.01 - cup.n.01) \n                    (and \n                        (inside ?cup.n.01 ?cabinet.n.01) \n                        (not \n                            (inside ?bowl.n.01_1 ?cabinet.n.01)\n                        )\n                    )\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_cloth)\n:parameters (?rag - piece_of_cloth.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_microwave_oven_0_Benevolence_1_int_0_2021-09-11_01-27-10",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_microwave_oven_0)\n    (:domain igibson)\n\n    (:objects\n     \tmicrowave.n.02_1 - microwave.n.02\n    \trag.n.01_1 - rag.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \tashcan.n.01_1 - ashcan.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty microwave.n.02_1) \n        (stained microwave.n.02_1) \n        (ontop rag.n.01_1 countertop.n.01_1) \n        (onfloor ashcan.n.01_1 floor.n.01_1) \n        (inroom microwave.n.02_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?microwave.n.02_1)\n            ) \n            (not \n                (stained ?microwave.n.02_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_out_drawers_0_Benevolence_1_int_0_2021-10-20_05-03-27",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_out_drawers_0)\n    (:domain igibson)\n\n    (:objects\n     \tbowl.n.01_1 bowl.n.01_2 - bowl.n.01\n    \tcabinet.n.01_1 cabinet.n.01_2 - cabinet.n.01\n    \tspoon.n.01_1 spoon.n.01_2 - spoon.n.01\n    \tpiece_of_cloth.n.01_1 - piece_of_cloth.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (inside bowl.n.01_1 cabinet.n.01_1) \n        (inside bowl.n.01_2 cabinet.n.01_1) \n        (inside spoon.n.01_1 cabinet.n.01_2) \n        (inside spoon.n.01_2 cabinet.n.01_2) \n        (inside piece_of_cloth.n.01_1 cabinet.n.01_1) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom cabinet.n.01_2 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (nextto ?piece_of_cloth.n.01_1 ?sink.n.01_1) \n            (nextto ?bowl.n.01_1 ?sink.n.01_1) \n            (nextto ?bowl.n.01_2 ?sink.n.01_1) \n            (nextto ?spoon.n.01_1 ?sink.n.01_1) \n            (nextto ?spoon.n.01_2 ?sink.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_oven_0_Benevolence_1_int_0_2021-09-11_12-20-40",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_oven_0)\n    (:domain igibson)\n\n    (:objects\n     \treceptacle.n.01_1 - receptacle.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \trag.n.01_1 rag.n.01_2 - rag.n.01\n    \tnewspaper.n.03_1 - newspaper.n.03\n    \tsink.n.01_1 - sink.n.01\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n    \toven.n.01_1 - oven.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor receptacle.n.01_1 floor.n.01_1) \n        (inside soap.n.01_1 cabinet.n.01_1) \n        (inside rag.n.01_1 cabinet.n.01_1) \n        (inside rag.n.01_2 cabinet.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (not \n            (soaked rag.n.01_2)\n        ) \n        (onfloor newspaper.n.03_1 floor.n.01_1) \n        (inside scrub_brush.n.01_1 cabinet.n.01_1) \n        (not \n            (soaked scrub_brush.n.01_1)\n        ) \n        (stained oven.n.01_1) \n        (inroom oven.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?rag.n.01 - rag.n.01) \n                (soaked ?rag.n.01)\n            ) \n            (soaked ?scrub_brush.n.01_1) \n            (not \n                (stained ?oven.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_shoes_0_Pomaria_2_int_0_2021-09-11_13-59-22",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_shoes_0)\n    (:domain igibson)\n\n    (:objects\n     \tsoap.n.01_1 - soap.n.01\n    \tbed.n.01_1 - bed.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \ttowel.n.01_1 - towel.n.01\n    \tshoe.n.01_1 shoe.n.01_2 shoe.n.01_3 shoe.n.01_4 - shoe.n.01\n        sink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop soap.n.01_1 bed.n.01_1) \n        (ontop rag.n.01_1 bed.n.01_1) \n        (onfloor towel.n.01_1 floor.n.01_1) \n        (ontop shoe.n.01_1 bed.n.01_1) \n        (ontop shoe.n.01_2 bed.n.01_1) \n        (ontop shoe.n.01_3 bed.n.01_1) \n        (ontop shoe.n.01_4 bed.n.01_1) \n        (stained shoe.n.01_1) \n        (stained shoe.n.01_2) \n        (dusty shoe.n.01_3) \n        (dusty shoe.n.01_4) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (inroom floor.n.01_1 bedroom) \n        (inroom bed.n.01_1 bedroom) \n        (inroom sink.n.01_1 bathroom)\n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?shoe.n.01 - shoe.n.01) \n                (not \n                    (stained ?shoe.n.01)\n                )\n            ) \n            (forall \n                (?shoe.n.01 - shoe.n.01) \n                (not \n                    (dusty ?shoe.n.01)\n                )\n            ) \n            (onfloor ?towel.n.01_1 ?floor.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_sneakers_0_Pomaria_1_int_0_2021-10-26_13-36-08",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_sneakers_0)\n    (:domain igibson)\n\n    (:objects\n     \tgym_shoe.n.01_1 gym_shoe.n.01_2 gym_shoe.n.01_3 gym_shoe.n.01_4 - gym_shoe.n.01\n            countertop.n.01_1 - countertop.n.01\n            soap.n.01_1 - soap.n.01\n            cabinet.n.01_1 - cabinet.n.01\n            towel.n.01_1 - towel.n.01\n            brush.n.02_1 - brush.n.02\n            sink.n.01_1 - sink.n.01\n            floor.n.01_1 floor.n.01_2 - floor.n.01\n            table.n.02_1 - table.n.02\n            agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor gym_shoe.n.01_1 floor.n.01_2) \n        (stained gym_shoe.n.01_1) \n        (onfloor gym_shoe.n.01_2 floor.n.01_2) \n        (stained gym_shoe.n.01_2) \n        (onfloor gym_shoe.n.01_3 floor.n.01_2) \n        (dusty gym_shoe.n.01_3) \n        (onfloor gym_shoe.n.01_4 floor.n.01_2) \n        (dusty gym_shoe.n.01_4) \n        (inside soap.n.01_1 cabinet.n.01_1) \n        (ontop towel.n.01_1 countertop.n.01_1) \n        (not \n            (stained towel.n.01_1)\n        ) \n        (ontop brush.n.02_1 countertop.n.01_1) \n        (not \n            (stained brush.n.02_1)\n        ) \n        (inroom sink.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 living_room) \n        (inroom table.n.02_1 living_room) \n        (inroom floor.n.01_2 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (ontop ?towel.n.01_1 ?countertop.n.01_1) \n            (nextto ?brush.n.02_1 ?towel.n.01_1) \n            (inside ?soap.n.01_1 ?sink.n.01_1) \n            (forall \n                (?gym_shoe.n.01 - gym_shoe.n.01) \n                (not \n                    (dusty ?gym_shoe.n.01)\n                )\n            ) \n            (forall \n                (?gym_shoe.n.01 - gym_shoe.n.01) \n                (not \n                    (stained ?gym_shoe.n.01)\n                )\n            ) \n            (forn \n                (2) \n                (?gym_shoe.n.01 - gym_shoe.n.01) \n                (nextto ?gym_shoe.n.01 ?table.n.02_1)\n            ) \n            (forn \n                (2) \n                (?gym_shoe.n.01 - gym_shoe.n.01) \n                (under ?gym_shoe.n.01 ?table.n.02_1)\n            ) \n            (forall \n                (?gym_shoe.n.01 - gym_shoe.n.01) \n                (onfloor ?gym_shoe.n.01 ?floor.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_under)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_stove_0_Wainscott_0_int_0_2021-09-11_12-51-07",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_stove_0)\n    (:domain igibson)\n\n    (:objects\n     \tstove.n.01_1 - stove.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tdishtowel.n.01_1 - dishtowel.n.01\n            floor.n.01_1 - floor.n.01\n            agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty stove.n.01_1) \n        (stained stove.n.01_1) \n        (inside soap.n.01_1 cabinet.n.01_1) \n        (inside rag.n.01_1 cabinet.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (not \n            (stained rag.n.01_1)\n        ) \n        (inside dishtowel.n.01_1 cabinet.n.01_1) \n        (not \n            (soaked dishtowel.n.01_1)\n        ) \n        (inroom sink.n.01_1 kitchen) \n        (inroom stove.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?stove.n.01_1)\n            ) \n            (not \n                (stained ?stove.n.01_1)\n            ) \n            (nextto ?rag.n.01_1 ?sink.n.01_1) \n            (nextto ?dishtowel.n.01_1 ?sink.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_dishtowel)\n:parameters (?hand_towel - dishtowel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_table_after_clearing_0_Merom_1_int_0_2021-06-06_19-48-44",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_table_after_clearing_0)\n    (:domain igibson)\n\n    (:objects\n     \ttable.n.02_1 - table.n.02\n    \tsoap.n.01_1 - soap.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tfloor.n.01_1 - floor.n.01\n            dishtowel.n.01_1 - dishtowel.n.01\n            cabinet.n.01_1 - cabinet.n.01\n            agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (stained table.n.02_1) \n        (inside soap.n.01_1 cabinet.n.01_1) \n        (inside dishtowel.n.01_1 cabinet.n.01_1) \n        (inroom table.n.02_1 dining_room) \n        (inroom floor.n.01_1 dining_room) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?table.n.02_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_dishtowel)\n:parameters (?hand_towel - dishtowel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_the_hot_tub_0_Ihlen_0_int_0_2021-08-24_22-19-07",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_the_hot_tub_0)\n    (:domain igibson)\n\n    (:objects\n     \tpool.n.01_1 - pool.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n        sink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor pool.n.01_1 floor.n.01_1) \n        (stained pool.n.01_1) \n        (onfloor scrub_brush.n.01_1 floor.n.01_1) \n        (inroom floor.n.01_1 garage) \n        (inroom sink.n.01_1 bathroom)\n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (onfloor ?pool.n.01_1 ?floor.n.01_1) \n            (not \n                (stained ?pool.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_the_pool_0_Ihlen_0_int_0_2021-06-01_15-30-31",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_the_pool_0)\n    (:domain igibson)\n\n    (:objects\n     \tpool.n.01_1 - pool.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n    \tshelf.n.01_1 - shelf.n.01\n    \tdetergent.n.02_1 - detergent.n.02\n        sink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor pool.n.01_1 floor.n.01_1) \n        (stained pool.n.01_1) \n        (onfloor scrub_brush.n.01_1 floor.n.01_1) \n        (onfloor detergent.n.02_1 floor.n.01_1) \n        (inroom shelf.n.01_1 garage) \n        (inroom floor.n.01_1 garage) \n        (inroom sink.n.01_1 storage_room)\n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (onfloor ?pool.n.01_1 ?floor.n.01_1) \n            (not \n                (stained ?pool.n.01_1)\n            ) \n            (ontop ?scrub_brush.n.01_1 ?shelf.n.01_1) \n            (onfloor ?detergent.n.02_1 ?floor.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_toilet_0_Merom_0_int_1_2021-06-23_17-35-48",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_toilet_0)\n    (:domain igibson)\n\n    (:objects\n     \ttoilet.n.02_1 - toilet.n.02\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tdetergent.n.02_1 - detergent.n.02\n        sink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (stained toilet.n.02_1) \n        (onfloor scrub_brush.n.01_1 floor.n.01_1) \n        (onfloor detergent.n.02_1 floor.n.01_1) \n        (inroom toilet.n.02_1 bathroom) \n        (inroom floor.n.01_1 bathroom) \n        (inroom sink.n.01_1 bathroom)\n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?toilet.n.02_1)\n            ) \n            (onfloor ?scrub_brush.n.01_1 ?floor.n.01_1) \n            (onfloor ?detergent.n.02_1 ?floor.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_up_after_a_meal_0_Wainscott_0_int_0_2021-10-20_05-33-24",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_up_after_a_meal_0)\n    (:domain igibson)\n\n    (:objects\n     \tbowl.n.01_1 bowl.n.01_2 - bowl.n.01\n    \ttable.n.02_1 - table.n.02\n    \tsack.n.01_1 - sack.n.01\n    \tchair.n.01_1 chair.n.01_2 - chair.n.01\n    \tplate.n.04_1 plate.n.04_2 plate.n.04_3 plate.n.04_4 - plate.n.04\n    \tcup.n.01_1 cup.n.01_2 - cup.n.01\n    \thamburger.n.01_1 hamburger.n.01_2 - hamburger.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \tdetergent.n.02_1 - detergent.n.02\n    \tdishwasher.n.01_1 - dishwasher.n.01\n        sink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop bowl.n.01_1 table.n.02_1) \n        (ontop bowl.n.01_2 table.n.02_1) \n        (stained bowl.n.01_1) \n        (stained bowl.n.01_2) \n        (ontop sack.n.01_1 table.n.02_1) \n        (ontop plate.n.04_1 table.n.02_1) \n        (ontop plate.n.04_2 table.n.02_1) \n        (ontop plate.n.04_3 table.n.02_1) \n        (ontop plate.n.04_4 table.n.02_1) \n        (stained plate.n.04_1) \n        (stained plate.n.04_2) \n        (stained plate.n.04_3) \n        (stained plate.n.04_4) \n        (ontop cup.n.01_1 table.n.02_1) \n        (ontop cup.n.01_2 table.n.02_1) \n        (stained cup.n.01_1) \n        (stained cup.n.01_2) \n        (ontop hamburger.n.01_1 chair.n.01_2) \n        (onfloor hamburger.n.01_2 floor.n.01_1) \n        (onfloor detergent.n.02_1 floor.n.01_1) \n        (stained chair.n.01_1) \n        (stained chair.n.01_2) \n        (stained table.n.02_1) \n        (inroom dishwasher.n.01_1 kitchen) \n        (inroom floor.n.01_1 dining_room) \n        (inroom floor.n.01_2 kitchen) \n        (inroom table.n.02_1 dining_room) \n        (inroom chair.n.01_1 dining_room) \n        (inroom chair.n.01_2 dining_room) \n        (inroom sink.n.01_1 kitchen)\n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?bowl.n.01 - bowl.n.01) \n                (not \n                    (stained ?bowl.n.01)\n                )\n            ) \n            (forall \n                (?plate.n.04 - plate.n.04) \n                (not \n                    (stained ?plate.n.04)\n                )\n            ) \n            (forall \n                (?cup.n.01 - cup.n.01) \n                (not \n                    (stained ?cup.n.01)\n                )\n            ) \n            (forall \n                (?hamburger.n.01 - hamburger.n.01) \n                (inside ?hamburger.n.01 ?sack.n.01_1)\n            ) \n            (onfloor ?sack.n.01_1 ?floor.n.01_1) \n            (not \n                (stained ?floor.n.01_1)\n            ) \n            (not \n                (stained ?chair.n.01_2)\n            ) \n            (not \n                (stained ?floor.n.01_1)\n            ) \n            (not \n                (stained ?table.n.02_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_dishwasher)\n:parameters (?dishwasher - dishwasher.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_up_refrigerator_0_Wainscott_0_int_1_2021-06-23_17-46-01",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_up_refrigerator_0)\n    (:domain igibson)\n\n    (:objects\n     \trag.n.01_1 rag.n.01_2 - rag.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \ttray.n.01_1 tray.n.01_2 - tray.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tbowl.n.01_1 - bowl.n.01\n    \tsink.n.01_1 - sink.n.01\n            agent.n.01_1 - agent.n.01\n            floor.n.01_1 - floor.n.01\n    )\n    \n    (:init \n        (inside rag.n.01_1 cabinet.n.01_1) \n        (inside rag.n.01_2 cabinet.n.01_1) \n        (ontop soap.n.01_1 countertop.n.01_1) \n        (inside tray.n.01_1 electric_refrigerator.n.01_1) \n        (inside tray.n.01_2 electric_refrigerator.n.01_1) \n        (inside bowl.n.01_1 electric_refrigerator.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (not \n            (soaked rag.n.01_2)\n        ) \n        (stained tray.n.01_1) \n        (stained tray.n.01_2) \n        (dusty bowl.n.01_1) \n        (stained electric_refrigerator.n.01_1) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?rag.n.01 - rag.n.01) \n                (nextto ?rag.n.01 ?sink.n.01_1)\n            ) \n            (inside ?soap.n.01_1 ?sink.n.01_1) \n            (forall \n                (?tray.n.01 - tray.n.01) \n                (inside ?tray.n.01 ?electric_refrigerator.n.01_1)\n            ) \n            (not \n                (stained ?tray.n.01_1)\n            ) \n            (not \n                (stained ?tray.n.01_2)\n            ) \n            (nextto ?bowl.n.01_1 ?sink.n.01_1) \n            (not \n                (dusty ?bowl.n.01_1)\n            ) \n            (not \n                (stained ?electric_refrigerator.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_up_the_kitchen_only_0_Pomaria_1_int_0_2021-10-26_00-50-16",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_up_the_kitchen_only_0)\n    (:domain igibson)\n\n    (:objects\n        bin.n.01_1 - bin.n.01\n        floor.n.01_1 - floor.n.01\n        soap.n.01_1 - soap.n.01\n        cabinet.n.01_1 cabinet.n.01_2 - cabinet.n.01\n        electric_refrigerator.n.01_1 - electric_refrigerator.n.01\n        rag.n.01_1 - rag.n.01\n        dustpan.n.02_1 - dustpan.n.02\n        broom.n.01_1 - broom.n.01\n        blender.n.01_1 - blender.n.01\n        sink.n.01_1 - sink.n.01\n        casserole.n.02_1 - casserole.n.02\n        plate.n.04_1 - plate.n.04\n        vegetable_oil.n.01_1 - vegetable_oil.n.01\n        apple.n.01_1 - apple.n.01\n        window.n.01_1 - window.n.01\n        countertop.n.01_1 - countertop.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor bin.n.01_1 floor.n.01_1) \n        (inside soap.n.01_1 cabinet.n.01_1) \n        (inside rag.n.01_1 cabinet.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (inside dustpan.n.02_1 cabinet.n.01_1) \n        (dusty dustpan.n.02_1) \n        (onfloor broom.n.01_1 floor.n.01_1) \n        (dusty broom.n.01_1) \n        (onfloor blender.n.01_1 floor.n.01_1) \n        (stained blender.n.01_1) \n        (inside casserole.n.02_1 electric_refrigerator.n.01_1) \n        (inside plate.n.04_1 electric_refrigerator.n.01_1) \n        (stained plate.n.04_1) \n        (inside vegetable_oil.n.01_1 electric_refrigerator.n.01_1) \n        (inside apple.n.01_1 electric_refrigerator.n.01_1) \n        (dusty floor.n.01_1) \n        (dusty cabinet.n.01_1) \n        (dusty cabinet.n.01_2) \n        (inroom floor.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom cabinet.n.01_2 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom window.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (ontop ?blender.n.01_1 ?countertop.n.01_1) \n            (nextto ?soap.n.01_1 ?sink.n.01_1) \n            (exists \n                (?cabinet.n.01 - cabinet.n.01) \n                (and \n                    (inside ?vegetable_oil.n.01_1 ?cabinet.n.01) \n                    (not \n                        (inside ?plate.n.04_1 ?cabinet.n.01)\n                    )\n                )\n            ) \n            (exists \n                (?cabinet.n.01 - cabinet.n.01) \n                (and \n                    (inside ?plate.n.04_1 ?cabinet.n.01) \n                    (not \n                        (inside ?vegetable_oil.n.01_1 ?cabinet.n.01)\n                    )\n                )\n            ) \n            (and \n                (not \n                    (dusty ?cabinet.n.01_1)\n                ) \n                (not \n                    (dusty ?cabinet.n.01_2)\n                ) \n                (not \n                    (dusty ?floor.n.01_1)\n                )\n            ) \n            (not \n                (stained ?plate.n.04_1)\n            ) \n            (or \n                (nextto ?rag.n.01_1 ?sink.n.01_1) \n                (inside ?rag.n.01_1 ?sink.n.01_1)\n            ) \n            (and \n                (inside ?casserole.n.02_1 ?electric_refrigerator.n.01_1) \n                (inside ?apple.n.01_1 ?electric_refrigerator.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_windows_0_Wainscott_0_int_0_2021-05-23_23-07-05",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem cleaning_windows_0)\n    (:domain igibson)\n\n    (:objects\n     \ttowel.n.01_1 towel.n.01_2 - towel.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \trag.n.01_1 rag.n.01_2 - rag.n.01\n    \tcleansing_agent.n.01_1 - cleansing_agent.n.01\n    \twindow.n.01_1 window.n.01_2 - window.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \ttable.n.02_1 - table.n.02\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (inside towel.n.01_1 cabinet.n.01_1) \n        (inside towel.n.01_2 cabinet.n.01_1) \n        (inside rag.n.01_1 cabinet.n.01_1) \n        (inside rag.n.01_2 cabinet.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (not \n            (soaked rag.n.01_2)\n        ) \n        (inside cleansing_agent.n.01_1 cabinet.n.01_1) \n        (dusty window.n.01_1) \n        (dusty window.n.01_2) \n        (not \n            (dusty sink.n.01_1)\n        ) \n        (inroom floor.n.01_1 kitchen) \n        (inroom floor.n.01_2 living_room) \n        (inroom window.n.01_1 kitchen) \n        (inroom window.n.01_2 living_room) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom table.n.02_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (and \n                (soaked ?rag.n.01_1) \n                (soaked ?rag.n.01_2)\n            ) \n            (and \n                (not \n                    (dusty ?window.n.01_1)\n                ) \n                (not \n                    (dusty ?window.n.01_2)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "clearing_the_table_after_dinner_0_Ihlen_0_int_0_2021-10-25_23-01-51",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem clearing_the_table_after_dinner_0)\n    (:domain igibson)\n\n    (:objects\n     \tfloor.n.01_1 - floor.n.01\n    \tchair.n.01_1 chair.n.01_2 - chair.n.01\n    \ttable.n.02_1 - table.n.02\n    \tcup.n.01_1 cup.n.01_2 - cup.n.01\n    \tbucket.n.01_1 bucket.n.01_2 - bucket.n.01\n    \tbowl.n.01_1 bowl.n.01_2 bowl.n.01_3 bowl.n.01_4 - bowl.n.01\n    \tcatsup.n.01_1 - catsup.n.01\n    \tbeverage.n.01_1 beverage.n.01_2 - beverage.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop cup.n.01_1 table.n.02_1) \n        (ontop cup.n.01_2 table.n.02_1) \n        (onfloor bucket.n.01_1 floor.n.01_1) \n        (ontop bowl.n.01_1 table.n.02_1) \n        (ontop bowl.n.01_2 table.n.02_1) \n        (ontop bowl.n.01_3 table.n.02_1) \n        (ontop bowl.n.01_4 table.n.02_1) \n        (ontop catsup.n.01_1 table.n.02_1) \n        (ontop beverage.n.01_1 table.n.02_1) \n        (onfloor beverage.n.01_2 floor.n.01_1) \n        (onfloor bucket.n.01_2 floor.n.01_1) \n        (inroom floor.n.01_1 dining_room) \n        (inroom chair.n.01_1 dining_room) \n        (inroom chair.n.01_2 dining_room) \n        (inroom table.n.02_1 dining_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?cup.n.01 - cup.n.01) \n                (exists \n                    (?bucket.n.01 - bucket.n.01) \n                    (inside ?cup.n.01 ?bucket.n.01)\n                )\n            ) \n            (forall \n                (?bowl.n.01 - bowl.n.01) \n                (exists \n                    (?bucket.n.01 - bucket.n.01) \n                    (inside ?bowl.n.01 ?bucket.n.01)\n                )\n            ) \n            (exists \n                (?bucket.n.01 - bucket.n.01) \n                (inside ?catsup.n.01_1 ?bucket.n.01)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "collecting_aluminum_cans_0_Ihlen_1_int_0_2021-06-06_20-13-28",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem collecting_aluminum_cans_0)\n    (:domain igibson)\n\n    (:objects\n     \tpop.n.02_1 pop.n.02_2 pop.n.02_3 pop.n.02_4 pop.n.02_5 pop.n.02_6 - pop.n.02\n    \tbed.n.01_1 - bed.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tbucket.n.01_1 - bucket.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop pop.n.02_1 bed.n.01_1) \n        (ontop pop.n.02_2 bed.n.01_1) \n        (ontop pop.n.02_3 bed.n.01_1) \n        (onfloor pop.n.02_4 floor.n.01_1) \n        (onfloor pop.n.02_5 floor.n.01_1) \n        (onfloor pop.n.02_6 floor.n.01_1) \n        (ontop bucket.n.01_1 bed.n.01_1) \n        (inroom bed.n.01_1 bedroom) \n        (inroom floor.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?pop.n.02 - pop.n.02) \n                (inside ?pop.n.02 ?bucket.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "collect_misplaced_items_0_Wainscott_0_int_1_2021-10-26_18-48-11",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem collect_misplaced_items_0)\n    (:domain igibson)\n\n    (:objects\n        gym_shoe.n.01_1 - gym_shoe.n.01\n        necklace.n.01_1 - necklace.n.01\n        notebook.n.01_1 - notebook.n.01\n        sock.n.01_1 sock.n.01_2 - sock.n.01\n        table.n.02_1 table.n.02_2 - table.n.02\n        cabinet.n.01_1 - cabinet.n.01\n        sofa.n.01_1 - sofa.n.01\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (under gym_shoe.n.01_1 table.n.02_1) \n        (onfloor gym_shoe.n.01_1 floor.n.01_2) \n        (inside necklace.n.01_1 cabinet.n.01_1) \n        (under notebook.n.01_1 table.n.02_2) \n        (ontop sock.n.01_1 sofa.n.01_1) \n        (onfloor sock.n.01_2 floor.n.01_1) \n        (inroom table.n.02_1 living_room) \n        (inroom cabinet.n.01_1 living_room) \n        (inroom table.n.02_2 dining_room) \n        (inroom sofa.n.01_1 living_room) \n        (inroom floor.n.01_1 living_room) \n        (inroom floor.n.01_2 dining_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (ontop ?gym_shoe.n.01_1 ?table.n.02_2) \n            (ontop ?necklace.n.01_1 ?table.n.02_2) \n            (ontop ?notebook.n.01_1 ?table.n.02_2) \n            (forall \n                (?sock.n.01 - sock.n.01) \n                (ontop ?sock.n.01 ?table.n.02_2)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "defrosting_freezer_0_Beechwood_0_int_0_2021-10-25_23-10-43",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem defrosting_freezer_0)\n    (:domain igibson)\n\n    (:objects\n     \tfloor.n.01_1 - floor.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \treceptacle.n.01_1 - receptacle.n.01\n    \tbucket.n.01_1 - bucket.n.01\n    \tscraper.n.01_1 - scraper.n.01\n    \ttowel.n.01_1 - towel.n.01\n    \trag.n.01_1 - rag.n.01\n    \tfood.n.02_1 food.n.02_2 food.n.02_3 - food.n.02\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (not \n            (stained sink.n.01_1)\n        ) \n        (onfloor receptacle.n.01_1 floor.n.01_1) \n        (onfloor bucket.n.01_1 floor.n.01_1) \n        (ontop scraper.n.01_1 countertop.n.01_1) \n        (ontop towel.n.01_1 countertop.n.01_1) \n        (not \n            (stained towel.n.01_1)\n        ) \n        (ontop rag.n.01_1 countertop.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (inside food.n.02_1 electric_refrigerator.n.01_1) \n        (inside food.n.02_2 electric_refrigerator.n.01_1) \n        (inside food.n.02_3 electric_refrigerator.n.01_1) \n        (inroom floor.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (nextto ?receptacle.n.01_1 ?electric_refrigerator.n.01_1) \n            (nextto ?bucket.n.01_1 ?countertop.n.01_1) \n            (ontop ?scraper.n.01_1 ?electric_refrigerator.n.01_1) \n            (ontop ?towel.n.01_1 ?countertop.n.01_1) \n            (inside ?rag.n.01_1 ?sink.n.01_1) \n            (soaked ?rag.n.01_1) \n            (forall \n                (?food.n.02 - food.n.02) \n                (inside ?food.n.02 ?bucket.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "filling_an_Easter_basket_0_Benevolence_1_int_1_2021-09-10_00-09-54",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem filling_an_Easter_basket_0)\n    (:domain igibson)\n\n    (:objects\n     \tbasket.n.01_1 basket.n.01_2 - basket.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \tball.n.01_1 - ball.n.01\n    \tjewelry.n.01_1 - jewelry.n.01\n    \tbook.n.02_1 book.n.02_2 - book.n.02\n    \tcabinet.n.01_1 cabinet.n.01_2 - cabinet.n.01\n    \tbow.n.08_1 bow.n.08_2 - bow.n.08\n    \tegg.n.02_1 egg.n.02_2 - egg.n.02\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tcandy.n.01_1 candy.n.01_2 - candy.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop basket.n.01_1 countertop.n.01_1) \n        (ontop basket.n.01_2 countertop.n.01_1) \n        (ontop ball.n.01_1 countertop.n.01_1) \n        (ontop jewelry.n.01_1 countertop.n.01_1) \n        (inside book.n.02_1 cabinet.n.01_1) \n        (inside book.n.02_2 cabinet.n.01_1) \n        (inside bow.n.08_1 cabinet.n.01_2) \n        (inside bow.n.08_2 cabinet.n.01_2) \n        (inside egg.n.02_1 electric_refrigerator.n.01_1) \n        (cooked egg.n.02_1) \n        (inside egg.n.02_2 electric_refrigerator.n.01_1) \n        (cooked egg.n.02_2) \n        (ontop candy.n.01_1 electric_refrigerator.n.01_1) \n        (ontop candy.n.01_2 electric_refrigerator.n.01_1) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom cabinet.n.01_2 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?basket.n.01 - basket.n.01) \n                (ontop ?basket.n.01 ?countertop.n.01_1)\n            ) \n            (forpairs \n                (?basket.n.01 - basket.n.01) \n                (?egg.n.02 - egg.n.02) \n                (inside ?egg.n.02 ?basket.n.01)\n            ) \n            (forpairs \n                (?basket.n.01 - basket.n.01) \n                (?candy.n.01 - candy.n.01) \n                (inside ?candy.n.01 ?basket.n.01)\n            ) \n            (exists \n                (?basket.n.01 - basket.n.01) \n                (and \n                    (inside ?jewelry.n.01_1 ?basket.n.01) \n                    (inside ?ball.n.01_1 ?basket.n.01)\n                )\n            ) \n            (forpairs \n                (?bow.n.08 - bow.n.08) \n                (?basket.n.01 - basket.n.01) \n                (or \n                    (ontop ?bow.n.08 ?basket.n.01) \n                    (inside ?bow.n.08 ?basket.n.01)\n                )\n            ) \n            (forpairs \n                (?book.n.02 - book.n.02) \n                (?basket.n.01 - basket.n.01) \n                (nextto ?book.n.02 ?basket.n.01)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "filling_a_Christmas_stocking_0_Rs_int_0_2021-06-04_18-47-42",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem filling_a_Christmas_stocking_0)\n    (:domain igibson)\n\n    (:objects\n     \tcube.n.05_1 cube.n.05_2 cube.n.05_3 cube.n.05_4 - cube.n.05\n    \tfloor.n.01_1 - floor.n.01\n    \tcandy.n.01_1 candy.n.01_2 candy.n.01_3 candy.n.01_4 - candy.n.01\n    \tcabinet.n.01_1 cabinet.n.01_2 - cabinet.n.01\n    \tpen.n.01_1 pen.n.01_2 pen.n.01_3 pen.n.01_4 - pen.n.01\n    \tstocking.n.01_1 stocking.n.01_2 stocking.n.01_3 stocking.n.01_4 - stocking.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor cube.n.05_1 floor.n.01_1) \n        (onfloor cube.n.05_2 floor.n.01_1) \n        (onfloor cube.n.05_3 floor.n.01_1) \n        (onfloor cube.n.05_4 floor.n.01_1) \n        (inside candy.n.01_1 cabinet.n.01_1) \n        (inside candy.n.01_2 cabinet.n.01_1) \n        (inside candy.n.01_3 cabinet.n.01_1) \n        (inside candy.n.01_4 cabinet.n.01_1) \n        (inside pen.n.01_1 cabinet.n.01_1) \n        (inside pen.n.01_2 cabinet.n.01_1) \n        (inside pen.n.01_3 cabinet.n.01_1) \n        (inside pen.n.01_4 cabinet.n.01_1) \n        (onfloor stocking.n.01_1 floor.n.01_1) \n        (onfloor stocking.n.01_2 floor.n.01_1) \n        (onfloor stocking.n.01_3 floor.n.01_1) \n        (onfloor stocking.n.01_4 floor.n.01_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom cabinet.n.01_2 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forpairs \n                (?stocking.n.01 - stocking.n.01) \n                (?cube.n.05 - cube.n.05) \n                (inside ?cube.n.05 ?stocking.n.01)\n            ) \n            (forpairs \n                (?stocking.n.01 - stocking.n.01) \n                (?candy.n.01 - candy.n.01) \n                (inside ?candy.n.01 ?stocking.n.01)\n            ) \n            (forpairs \n                (?stocking.n.01 - stocking.n.01) \n                (?pen.n.01 - pen.n.01) \n                (inside ?pen.n.01 ?stocking.n.01)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "installing_alarms_0_Merom_1_int_0_2021-05-23_23-02-24",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem installing_alarms_0)\n    (:domain igibson)\n\n    (:objects\n     \talarm.n.02_1 alarm.n.02_2 - alarm.n.02\n    \ttable.n.02_1 table.n.02_2 - table.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop alarm.n.02_1 table.n.02_2) \n        (ontop alarm.n.02_2 table.n.02_2) \n        (not \n            (toggled_on alarm.n.02_1)\n        ) \n        (not \n            (toggled_on alarm.n.02_2)\n        ) \n        (inroom table.n.02_1 dining_room) \n        (inroom table.n.02_2 living_room) \n        (inroom floor.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forpairs \n                (?alarm.n.02 - alarm.n.02) \n                (?table.n.02 - table.n.02) \n                (ontop ?alarm.n.02 ?table.n.02)\n            ) \n            (forall \n                (?alarm.n.02 - alarm.n.02) \n                (toggled_on ?alarm.n.02)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "installing_a_fax_machine_0_Beechwood_0_int_0_2021-10-25_20-22-22",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem installing_a_fax_machine_0)\n    (:domain igibson)\n\n    (:objects\n     \tfacsimile.n.02_1 - facsimile.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \ttable.n.02_1 - table.n.02\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor facsimile.n.02_1 floor.n.01_1) \n        (not \n            (toggled_on facsimile.n.02_1)\n        ) \n        (inroom table.n.02_1 home_office) \n        (inroom floor.n.01_1 home_office) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (ontop ?facsimile.n.02_1 ?table.n.02_1) \n            (toggled_on ?facsimile.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "installing_a_modem_0_Beechwood_0_int_0_2021-10-25_20-28-55",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem installing_a_modem_0)\n    (:domain igibson)\n\n    (:objects\n     \tmodem.n.01_1 - modem.n.01\n    \ttable.n.02_1 - table.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (not \n            (toggled_on modem.n.01_1)\n        ) \n        (ontop modem.n.01_1 table.n.02_1) \n        (inroom table.n.02_1 home_office) \n        (inroom floor.n.01_1 home_office) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (toggled_on ?modem.n.01_1) \n            (under ?modem.n.01_1 ?table.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_under)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "installing_a_printer_0_Pomaria_0_int_0_2021-06-08_18-33-07",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem installing_a_printer_0)\n    (:domain igibson)\n\n    (:objects\n     \tprinter.n.03_1 - printer.n.03\n    \tfloor.n.01_1 - floor.n.01\n    \ttable.n.02_1 - table.n.02\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor printer.n.03_1 floor.n.01_1) \n        (not \n            (toggled_on printer.n.03_1)\n        ) \n        (inroom table.n.02_1 home_office) \n        (inroom floor.n.01_1 home_office) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (ontop ?printer.n.03_1 ?table.n.02_1) \n            (toggled_on ?printer.n.03_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "installing_a_scanner_0_Pomaria_0_int_0_2021-06-08_18-34-59",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem installing_a_scanner_0)\n    (:domain igibson)\n\n    (:objects\n     \tscanner.n.02_1 - scanner.n.02\n    \ttable.n.02_1 - table.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop scanner.n.02_1 table.n.02_1) \n        (not \n            (toggled_on scanner.n.02_1)\n        ) \n        (inroom table.n.02_1 home_office) \n        (inroom floor.n.01_1 home_office) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (toggled_on ?scanner.n.02_1) \n            (under ?scanner.n.02_1 ?table.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_under)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "laying_tile_floors_0_Beechwood_0_int_0_2021-10-26_17-26-23",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem laying_tile_floors_0)\n    (:domain igibson)\n\n    (:objects\n        tile.n.01_1 tile.n.01_2 tile.n.01_3 tile.n.01_4 - tile.n.01\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor tile.n.01_1 floor.n.01_1) \n        (onfloor tile.n.01_2 floor.n.01_1) \n        (onfloor tile.n.01_3 floor.n.01_1) \n        (onfloor tile.n.01_4 floor.n.01_1) \n        (inroom floor.n.01_1 corridor) \n        (inroom floor.n.01_2 bathroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?tile.n.01 - tile.n.01) \n                (onfloor ?tile.n.01 ?floor.n.01_2)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "laying_wood_floors_0_Pomaria_1_int_0_2021-10-25_20-46-59",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem laying_wood_floors_0)\n    (:domain igibson)\n\n    (:objects\n     \tplywood.n.01_1 plywood.n.01_2 plywood.n.01_3 plywood.n.01_4 - plywood.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \thammer.n.02_1 - hammer.n.02\n    \tsaw.n.02_1 - saw.n.02\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor plywood.n.01_1 floor.n.01_1) \n        (onfloor plywood.n.01_2 floor.n.01_1) \n        (onfloor plywood.n.01_3 floor.n.01_1) \n        (onfloor plywood.n.01_4 floor.n.01_1) \n        (onfloor hammer.n.02_1 floor.n.01_1) \n        (onfloor saw.n.02_1 floor.n.01_1) \n        (inroom floor.n.01_1 kitchen) \n        (inroom floor.n.01_2 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?plywood.n.01 - plywood.n.01) \n                (onfloor ?plywood.n.01 ?floor.n.01_2)\n            ) \n            (forall \n                (?plywood.n.01 - plywood.n.01) \n                (or \n                    (nextto ?plywood.n.01 ?plywood.n.01_1) \n                    (nextto ?plywood.n.01 ?plywood.n.01_2) \n                    (nextto ?plywood.n.01 ?plywood.n.01_3) \n                    (nextto ?plywood.n.01 ?plywood.n.01_4)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "loading_the_dishwasher_0_Benevolence_1_int_0_2021-10-20_06-10-42",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem loading_the_dishwasher_0)\n    (:domain igibson)\n\n    (:objects\n        plate.n.04_1 plate.n.04_2 plate.n.04_3 - plate.n.04\n       countertop.n.01_1 - countertop.n.01\n        mug.n.04_1 - mug.n.04\n        bowl.n.01_1 bowl.n.01_2 - bowl.n.01\n        dishwasher.n.01_1 - dishwasher.n.01\n        floor.n.01_1 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop plate.n.04_1 countertop.n.01_1) \n        (stained plate.n.04_1) \n        (ontop plate.n.04_2 countertop.n.01_1) \n        (stained plate.n.04_2) \n        (ontop plate.n.04_3 countertop.n.01_1) \n        (stained plate.n.04_3) \n        (ontop mug.n.04_1 countertop.n.01_1) \n        (stained mug.n.04_1) \n        (ontop bowl.n.01_1 countertop.n.01_1) \n        (stained bowl.n.01_1) \n        (ontop bowl.n.01_2 countertop.n.01_1) \n        (stained bowl.n.01_2) \n        (inroom dishwasher.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?plate.n.04 - plate.n.04) \n                (inside ?plate.n.04 ?dishwasher.n.01_1)\n            ) \n            (forall \n                (?bowl.n.01 - bowl.n.01) \n                (inside ?bowl.n.01 ?dishwasher.n.01_1)\n            ) \n            (inside ?mug.n.04_1 ?dishwasher.n.01_1)\n        )\n    )\n)\n\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "locking_every_door_0_Merom_1_int_0_2021-10-20_05-53-14",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem locking_every_door_0)\n    (:domain igibson)\n\n    (:objects\n     \tdoor.n.01_1 door.n.01_2 - door.n.01\n    \tbed.n.01_1 - bed.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (open door.n.01_1) \n        (open door.n.01_2) \n        (inroom door.n.01_1 bedroom) \n        (inroom door.n.01_2 bathroom) \n        (inroom bed.n.01_1 bedroom) \n        (inroom floor.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (open ?door.n.01_1)\n            ) \n            (not \n                (open ?door.n.01_2)\n            )\n        )\n    )\n)\n\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "locking_every_window_0_Merom_1_int_0_2021-11-01_14-51-10",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem locking_every_window_0)\n    (:domain igibson)\n\n    (:objects\n     \twindow.n.01_1 window.n.01_2 window.n.01_3 window.n.01_4 - window.n.01\n    \tbed.n.01_1 - bed.n.01\n    \tsofa.n.01_1 - sofa.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (open window.n.01_1) \n        (open window.n.01_2) \n        (open window.n.01_3) \n        (open window.n.01_4) \n        (inroom window.n.01_1 bedroom) \n        (inroom window.n.01_2 kitchen) \n        (inroom window.n.01_3 living_room) \n        (inroom window.n.01_4 living_room) \n        (inroom bed.n.01_1 bedroom) \n        (inroom sofa.n.01_1 living_room) \n        (inroom floor.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (open ?window.n.01_1)\n            ) \n            (not \n                (open ?window.n.01_2)\n            ) \n            (not \n                (open ?window.n.01_3)\n            ) \n            (not \n                (open ?window.n.01_4)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "making_tea_0_Wainscott_0_int_0_2021-10-26_12-49-48",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem making_tea_0)\n    (:domain igibson)\n\n    (:objects \n        teapot.n.01_1 - teapot.n.01\n        tea_bag.n.01_1 - tea_bag.n.01\n        lemon.n.01_1 - lemon.n.01\n        knife.n.01_1 - knife.n.01\n        cabinet.n.01_1 - cabinet.n.01\n        electric_refrigerator.n.01_1 - electric_refrigerator.n.01\n        stove.n.01_1 - stove.n.01\n        floor.n.01_1 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (inside teapot.n.01_1 cabinet.n.01_1) \n        (inside tea_bag.n.01_1 cabinet.n.01_1) \n        (inside lemon.n.01_1 electric_refrigerator.n.01_1) \n        (inside knife.n.01_1 cabinet.n.01_1) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom stove.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (sliced ?lemon.n.01_1) \n            (ontop ?teapot.n.01_1 ?stove.n.01_1) \n            (inside ?tea_bag.n.01_1 ?teapot.n.01_1) \n            (soaked ?tea_bag.n.01_1) \n            (toggled_on ?stove.n.01_1)\n        )\n    )\n)\n\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action soak_teapot)\n:parameters (?obj1 - object ?agent - agent.n.01 ?teapot - teapot.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action slice)\n:parameters (?obj - object ?knife - carving_knife.n.01 ?board - countertop.n.01 ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "mopping_floors_0_Benevolence_2_int_0_2021-10-25_21-01-58",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem mopping_floors_0)\n    (:domain igibson)\n\n    (:objects\n     \tbroom.n.01_1 - broom.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \tbucket.n.01_1 - bucket.n.01\n    \tpiece_of_cloth.n.01_1 - piece_of_cloth.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor broom.n.01_1 floor.n.01_2) \n        (onfloor soap.n.01_1 floor.n.01_1) \n        (onfloor bucket.n.01_1 floor.n.01_1) \n        (onfloor piece_of_cloth.n.01_1 floor.n.01_1) \n        (stained floor.n.01_1) \n        (inroom floor.n.01_1 bathroom) \n        (inroom floor.n.01_2 corridor) \n        (inroom sink.n.01_1 bathroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (stained ?floor.n.01_1)\n            ) \n            (nextto ?bucket.n.01_1 ?sink.n.01_1) \n            (inside ?soap.n.01_1 ?bucket.n.01_1) \n            (nextto ?broom.n.01_1 ?sink.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_cloth)\n:parameters (?rag - piece_of_cloth.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "moving_boxes_to_storage_0_Merom_0_int_0_2021-06-11_20-04-35",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem moving_boxes_to_storage_0)\n    (:domain igibson)\n\n    (:objects\n        carton.n.02_1 carton.n.02_2 - carton.n.02\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \tshelf.n.01_1 - shelf.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor carton.n.02_1 floor.n.01_1)\n        (onfloor carton.n.02_2 floor.n.01_1)\n        (inroom floor.n.01_1 living_room) \n        (inroom floor.n.01_2 storage_room) \n        (inroom shelf.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (onfloor ?carton.n.02_1 ?floor.n.01_2)\n            (ontop ?carton.n.02_2 ?carton.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "opening_packages_0_Benevolence_2_int_0_2021-10-25_21-06-42",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem opening_packages_0)\n    (:domain igibson)\n\n    (:objects\n     \tpackage.n.02_1 package.n.02_2 - package.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor package.n.02_1 floor.n.01_1) \n        (onfloor package.n.02_2 floor.n.01_1) \n        (not \n            (open package.n.02_1)\n        ) \n        (not \n            (open package.n.02_2)\n        ) \n        (inroom floor.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?package.n.02 - package.n.02) \n                (open ?package.n.02)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "opening_presents_0_Benevolence_2_int_0_2021-10-25_21-10-48",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem opening_presents_0)\n    (:domain igibson)\n\n    (:objects\n     \tpackage.n.02_1 package.n.02_2 - package.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tbed.n.01_1 - bed.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor package.n.02_1 floor.n.01_1) \n        (onfloor package.n.02_2 floor.n.01_1) \n        (not \n            (open package.n.02_1)\n        ) \n        (not \n            (open package.n.02_2)\n        ) \n        (inroom bed.n.01_1 bedroom) \n        (inroom floor.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?package.n.02 - package.n.02) \n                (open ?package.n.02)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "organizing_boxes_in_garage_0_Ihlen_0_int_0_2021-08-24_22-59-54",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem organizing_boxes_in_garage_0)\n    (:domain igibson)\n\n    (:objects\n     \tcarton.n.02_1 carton.n.02_2 - carton.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tball.n.01_1 ball.n.01_2 - ball.n.01\n    \tplate.n.04_1 plate.n.04_2 plate.n.04_3 - plate.n.04\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tsaucepan.n.01_1 - saucepan.n.01\n    \tshelf.n.01_1 - shelf.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (onfloor carton.n.02_2 floor.n.01_1) \n        (onfloor ball.n.01_1 floor.n.01_1) \n        (onfloor ball.n.01_2 floor.n.01_1) \n        (inside plate.n.04_1 shelf.n.01_1) \n        (inside plate.n.04_2 shelf.n.01_1) \n        (inside plate.n.04_3 shelf.n.01_1) \n        (inside saucepan.n.01_1 shelf.n.01_1) \n        (inroom floor.n.01_1 garage) \n        (inroom shelf.n.01_1 garage) \n        (inroom cabinet.n.01_1 garage) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (exists \n                (?carton.n.02 - carton.n.02) \n                (and \n                    (forall \n                        (?ball.n.01 - ball.n.01) \n                        (inside ?ball.n.01 ?carton.n.02)\n                    ) \n                    (forall \n                        (?plate.n.04 - plate.n.04) \n                        (inside ?plate.n.04 ?carton.n.02)\n                    ) \n                    (inside ?saucepan.n.01_1 ?carton.n.02)\n                )\n            ) \n            (forall \n                (?carton.n.02 - carton.n.02) \n                (onfloor ?carton.n.02 floor.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "organizing_file_cabinet_0_Pomaria_0_int_0_2021-06-08_15-27-20",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem organizing_file_cabinet_0)\n    (:domain igibson)\n\n    (:objects\n        floor.n.01_1 - floor.n.01\n        marker.n.03_1 - marker.n.03\n        chair.n.01_1 - chair.n.01\n        document.n.01_1 document.n.01_2 document.n.01_3 document.n.01_4 - document.n.01\n        table.n.02_1 - table.n.02\n        cabinet.n.01_1 - cabinet.n.01\n        folder.n.02_1 folder.n.02_2 - folder.n.02\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop marker.n.03_1 chair.n.01_1) \n        (ontop document.n.01_1 table.n.02_1) \n        (inside document.n.01_2 cabinet.n.01_1) \n        (ontop document.n.01_3 table.n.02_1) \n        (inside document.n.01_4 cabinet.n.01_1) \n        (ontop folder.n.02_1 table.n.02_1) \n        (onfloor folder.n.02_2 floor.n.01_1) \n        (inroom cabinet.n.01_1 home_office) \n        (inroom table.n.02_1 home_office) \n        (inroom chair.n.01_1 home_office) \n        (inroom floor.n.01_1 home_office) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (ontop ?marker.n.03_1 ?table.n.02_1) \n            (forall \n                (?document.n.01 - document.n.01) \n                (inside ?document.n.01 ?cabinet.n.01_1)\n            ) \n            (forall \n                (?folder.n.02 - folder.n.02) \n                (inside ?folder.n.02 ?cabinet.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "organizing_school_stuff_0_Wainscott_1_int_0_2021-08-24_22-56-24",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem organizing_school_stuff_0)\n    (:domain igibson)\n\n    (:objects\n     \thighlighter.n.02_1 - highlighter.n.02\n    \tbed.n.01_1 - bed.n.01\n    \tpencil.n.01_1 - pencil.n.01\n    \tpen.n.01_1 - pen.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tcalculator.n.02_1 - calculator.n.02\n    \tbook.n.02_1 - book.n.02\n    \tfolder.n.02_1 - folder.n.02\n        table.n.02_1 - table.n.02\n    \tbackpack.n.01_1 - backpack.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop highlighter.n.02_1 bed.n.01_1) \n        (ontop pencil.n.01_1 bed.n.01_1) \n        (onfloor pen.n.01_1 floor.n.01_1) \n        (onfloor calculator.n.02_1 floor.n.01_1) \n        (ontop book.n.02_1 bed.n.01_1) \n        (ontop folder.n.02_1 bed.n.01_1) \n        (onfloor backpack.n.01_1 floor.n.01_1) \n        (inroom floor.n.01_1 bedroom) \n        (inroom bed.n.01_1 bedroom) \n        (inroom table.n.02_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (and \n                (nextto ?folder.n.02_1 ?backpack.n.01_1) \n                (nextto ?book.n.02_1 ?backpack.n.01_1)\n            ) \n            (inside ?highlighter.n.02_1 ?backpack.n.01_1) \n            (inside ?pencil.n.01_1 ?backpack.n.01_1) \n            (inside ?pen.n.01_1 ?backpack.n.01_1) \n            (inside ?calculator.n.02_1 ?backpack.n.01_1) \n            (ontop ?backpack.n.01_1 ?bed.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "packing_adult_s_bags_0_Ihlen_1_int_0_2021-10-26_09-54-15",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem packing_adult_s_bags_0)\n    (:domain igibson)\n\n    (:objects\n        backpack.n.01_1 - backpack.n.01\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        hanger.n.02_1 - hanger.n.02\n        bed.n.01_1 - bed.n.01\n        makeup.n.01_1 makeup.n.01_2 - makeup.n.01\n        jewelry.n.01_1 jewelry.n.01_2 - jewelry.n.01\n        toothbrush.n.01_1 - toothbrush.n.01\n        mouse.n.04_1 - mouse.n.04\n        door.n.01_1 - door.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor backpack.n.01_1 floor.n.01_1) \n        (ontop hanger.n.02_1 bed.n.01_1) \n        (ontop makeup.n.01_1 bed.n.01_1) \n        (ontop makeup.n.01_2 bed.n.01_1) \n        (ontop toothbrush.n.01_1 bed.n.01_1) \n        (onfloor jewelry.n.01_1 floor.n.01_1) \n        (onfloor jewelry.n.01_2 floor.n.01_1) \n        (ontop mouse.n.04_1 bed.n.01_1) \n        (open door.n.01_1) \n        (inroom floor.n.01_1 bedroom) \n        (inroom floor.n.01_2 corridor) \n        (inroom door.n.01_1 bedroom) \n        (inroom bed.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?jewelry.n.01 - jewelry.n.01) \n                (inside ?jewelry.n.01 ?backpack.n.01_1)\n            ) \n            (forall \n                (?makeup.n.01 - makeup.n.01) \n                (inside ?makeup.n.01 ?backpack.n.01_1)\n            ) \n            (inside ?toothbrush.n.01_1 ?backpack.n.01_1) \n            (inside ?mouse.n.04_1 ?backpack.n.01_1) \n            (onfloor ?backpack.n.01_1 ?floor.n.01_2)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "packing_bags_or_suitcase_0_Merom_1_int_0_2021-10-26_10-04-07",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem packing_bags_or_suitcase_0)\n    (:domain igibson)\n\n    (:objects\n     \tbackpack.n.01_1 - backpack.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \ttoothbrush.n.01_1 - toothbrush.n.01\n    \tbed.n.01_1 - bed.n.01\n    \tshampoo.n.01_1 - shampoo.n.01\n    \thardback.n.01_1 - hardback.n.01\n    \tunderwear.n.01_1 underwear.n.01_2 - underwear.n.01\n    \ttoothpaste.n.01_1 - toothpaste.n.01\n    \tdoor.n.01_1 - door.n.01\n    \twindow.n.01_1 - window.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor backpack.n.01_1 floor.n.01_1) \n        (ontop toothbrush.n.01_1 bed.n.01_1) \n        (ontop shampoo.n.01_1 bed.n.01_1) \n        (ontop hardback.n.01_1 bed.n.01_1) \n        (ontop underwear.n.01_1 bed.n.01_1) \n        (ontop underwear.n.01_2 bed.n.01_1) \n        (ontop toothpaste.n.01_1 bed.n.01_1) \n        (inroom bed.n.01_1 bedroom) \n        (inroom floor.n.01_1 bedroom) \n        (inroom door.n.01_1 bedroom) \n        (inroom window.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?underwear.n.01 - underwear.n.01) \n                (inside ?underwear.n.01 ?backpack.n.01_1)\n            ) \n            (inside ?toothbrush.n.01_1 ?backpack.n.01_1) \n            (inside ?shampoo.n.01_1 ?backpack.n.01_1) \n            (inside ?hardback.n.01_1 ?backpack.n.01_1) \n            (inside ?toothpaste.n.01_1 ?backpack.n.01_1) \n            (or \n                (ontop ?backpack.n.01_1 ?bed.n.01_1) \n                (onfloor ?backpack.n.01_1 ?floor.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "packing_boxes_for_household_move_or_trip_0_Ihlen_1_int_0_2021-06-08_19-16-19",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem packing_boxes_for_household_move_or_trip_0)\n    (:domain igibson)\n\n    (:objects\n     \tcarton.n.02_1 carton.n.02_2 - carton.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tbook.n.02_1 book.n.02_2 - book.n.02\n    \ttable.n.02_1 - table.n.02\n    \tsweater.n.01_1 - sweater.n.01\n    \tshirt.n.01_1 shirt.n.01_2 - shirt.n.01\n    \tplate.n.04_1 plate.n.04_2 plate.n.04_3 plate.n.04_4 - plate.n.04\n    \tdishtowel.n.01_1 - dishtowel.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (onfloor carton.n.02_2 floor.n.01_1) \n        (ontop book.n.02_2 table.n.02_1) \n        (ontop book.n.02_1 table.n.02_1) \n        (onfloor sweater.n.01_1 floor.n.01_1) \n        (onfloor shirt.n.01_1 floor.n.01_1) \n        (onfloor shirt.n.01_2 floor.n.01_1) \n        (ontop plate.n.04_1 table.n.02_1) \n        (onfloor plate.n.04_2 floor.n.01_1) \n        (onfloor plate.n.04_3 floor.n.01_1) \n        (onfloor plate.n.04_4 floor.n.01_1) \n        (onfloor dishtowel.n.01_1 floor.n.01_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom table.n.02_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (exists \n                (?carton.n.02 - carton.n.02) \n                (and \n                    (forall \n                        (?plate.n.04 - plate.n.04) \n                        (inside ?plate.n.04 ?carton.n.02)\n                    ) \n                    (inside ?dishtowel.n.01_1 ?carton.n.02)\n                )\n            ) \n            (exists \n                (?carton.n.02 - carton.n.02) \n                (and \n                    (forall \n                        (?book.n.02 - book.n.02) \n                        (inside ?book.n.02 ?carton.n.02)\n                    ) \n                    (forall \n                        (?shirt.n.01 - shirt.n.01) \n                        (inside ?shirt.n.01 ?carton.n.02)\n                    ) \n                    (inside ?sweater.n.01_1 ?carton.n.02)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "packing_car_for_trip_0_Ihlen_0_int_0_2021-10-26_10-27-23",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem packing_car_for_trip_0)\n    (:domain igibson)\n\n    (:objects \n        car.n.01_1 - car.n.01\n        briefcase.n.01_1 - briefcase.n.01\n        pencil_box.n.01_1 - pencil_box.n.01\n        headset.n.01_1 - headset.n.01\n        duffel_bag.n.01_1 - duffel_bag.n.01\n        table.n.02_1 - table.n.02\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor car.n.01_1 floor.n.01_1) \n        (onfloor briefcase.n.01_1 floor.n.01_2) \n        (ontop pencil_box.n.01_1 table.n.02_1) \n        (ontop headset.n.01_1 table.n.02_1) \n        (onfloor duffel_bag.n.01_1 floor.n.01_2) \n        (inroom floor.n.01_1 garage) \n        (inroom floor.n.01_2 storage_room) \n        (inroom table.n.02_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (inside briefcase.n.01_1 car.n.01_1) \n            (inside pencil_box.n.01_1 car.n.01_1) \n            (inside headset.n.01_1 car.n.01_1) \n            (inside duffel_bag.n.01_1 car.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "packing_child_s_bag_0_Beechwood_1_int_0_2021-10-26_10-33-11",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem packing_child_s_bag_0)\n    (:domain igibson)\n\n    (:objects\n     \tbackpack.n.01_1 - backpack.n.01\n        notebook.n.01_1 - notebook.n.01\n        bracelet.n.02_1 - bracelet.n.02\n        apple.n.01_1 - apple.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tbed.n.01_1 - bed.n.01\n        earphone.n.01_1 - earphone.n.01\n    \tsunglass.n.01_1 - sunglass.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor backpack.n.01_1 floor.n.01_1) \n        (ontop sunglass.n.01_1 bed.n.01_1) \n        (ontop bracelet.n.02_1 bed.n.01_1) \n        (onfloor notebook.n.01_1 floor.n.01_1) \n        (ontop apple.n.01_1 bed.n.01_1) \n        (ontop earphone.n.01_1 bed.n.01_1) \n        (inroom bed.n.01_1 bedroom) \n        (inroom floor.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (nextto ?backpack.n.01_1 ?bed.n.01_1) \n            (inside ?sunglass.n.01_1 ?backpack.n.01_1) \n            (inside ?notebook.n.01_1 ?backpack.n.01_1) \n            (inside ?bracelet.n.02_1 ?backpack.n.01_1) \n            (inside ?apple.n.01_1 ?backpack.n.01_1) \n            (inside ?earphone.n.01_1 ?backpack.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "packing_food_for_work_0_Ihlen_1_int_0_2021-06-08_19-36-15",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem packing_food_for_work_0)\n    (:domain igibson)\n\n    (:objects\n        carton.n.02_1 - carton.n.02\n        countertop.n.01_1 - countertop.n.01\n        sandwich.n.01_1 - sandwich.n.01\n        electric_refrigerator.n.01_1 - electric_refrigerator.n.01\n        apple.n.01_1 - apple.n.01\n        snack_food.n.01_1 - snack_food.n.01\n        cabinet.n.01_1 - cabinet.n.01\n        juice.n.01_1 - juice.n.01\n        floor.n.01_1 - floor.n.01\n        door.n.01_1 - door.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (inside sandwich.n.01_1 electric_refrigerator.n.01_1) \n        (ontop apple.n.01_1 countertop.n.01_1) \n        (inside snack_food.n.01_1 cabinet.n.01_1) \n        (ontop juice.n.01_1 countertop.n.01_1) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (inroom door.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (inside ?sandwich.n.01_1 ?carton.n.02_1) \n            (inside ?apple.n.01_1 ?carton.n.02_1) \n            (inside ?snack_food.n.01_1 ?carton.n.02_1) \n            (inside ?juice.n.01_1 ?carton.n.02_1) \n            (or \n                (onfloor ?carton.n.02_1 ?floor.n.01_1) \n                (ontop ?carton.n.02_1 ?countertop.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "packing_lunches_0_Beechwood_0_int_0_2021-10-26_11-03-14",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem packing_lunches_0)\n    (:domain igibson)\n\n    (:objects\n     \tsalad.n.01_1 - salad.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tsandwich.n.01_1 - sandwich.n.01\n    \tchip.n.04_1 chip.n.04_2 - chip.n.04\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tjuice.n.01_1 - juice.n.01\n    \ttable.n.02_1 - table.n.02\n    \tpop.n.02_1 - pop.n.02\n    \tapple.n.01_1 - apple.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \tbanana.n.02_1 - banana.n.02\n    \tcarton.n.02_1 carton.n.02_2 - carton.n.02\n    \tcookie.n.01_1 cookie.n.01_2 - cookie.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (inside salad.n.01_1 electric_refrigerator.n.01_1) \n        (inside sandwich.n.01_1 electric_refrigerator.n.01_1) \n        (inside chip.n.04_1 cabinet.n.01_1) \n        (inside chip.n.04_2 cabinet.n.01_1) \n        (ontop juice.n.01_1 table.n.02_1) \n        (ontop pop.n.02_1 table.n.02_1) \n        (ontop apple.n.01_1 countertop.n.01_1) \n        (ontop banana.n.02_1 countertop.n.01_1) \n        (onfloor carton.n.02_1 floor.n.01_2) \n        (onfloor carton.n.02_2 floor.n.01_2) \n        (ontop cookie.n.01_1 countertop.n.01_1) \n        (ontop cookie.n.01_2 countertop.n.01_1) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom table.n.02_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (inroom floor.n.01_2 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forpairs \n                (?chip.n.04 - chip.n.04) \n                (?carton.n.02 - carton.n.02) \n                (inside ?chip.n.04 ?carton.n.02)\n            ) \n            (forpairs \n                (?cookie.n.01 - cookie.n.01) \n                (?carton.n.02 - carton.n.02) \n                (inside ?cookie.n.01 ?carton.n.02)\n            ) \n            (exists \n                (?carton.n.02 - carton.n.02) \n                (and \n                    (inside ?salad.n.01_1 ?carton.n.02) \n                    (inside ?juice.n.01_1 ?carton.n.02) \n                    (not \n                        (inside ?sandwich.n.01_1 ?carton.n.02)\n                    )\n                )\n            ) \n            (exists \n                (?carton.n.02 - carton.n.02) \n                (and \n                    (inside ?sandwich.n.01_1 ?carton.n.02) \n                    (inside ?pop.n.02_1 ?carton.n.02) \n                    (not \n                        (inside ?salad.n.01_1 ?carton.n.02)\n                    )\n                )\n            ) \n            (or \n                (inside ?apple.n.01_1 ?carton.n.02_1) \n                (inside ?banana.n.02_1 ?carton.n.02_1)\n            ) \n            (or \n                (inside ?apple.n.01_1 ?carton.n.02_2) \n                (inside ?banana.n.02_1 ?carton.n.02_2)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "packing_picnics_0_Wainscott_0_int_0_2021-10-26_11-07-29",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem packing_picnics_0)\n    (:domain igibson)\n\n    (:objects\n        carton.n.02_1 carton.n.02_2 carton.n.02_3 - carton.n.02\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        chip.n.04_1 chip.n.04_2 - chip.n.04\n        cabinet.n.01_1 - cabinet.n.01\n        sandwich.n.01_1 sandwich.n.01_2 sandwich.n.01_3 sandwich.n.01_4 - sandwich.n.01\n        countertop.n.01_1 - countertop.n.01\n        melon.n.01_1 - melon.n.01\n        strawberry.n.01_1 strawberry.n.01_2 strawberry.n.01_3 strawberry.n.01_4 - strawberry.n.01\n        electric_refrigerator.n.01_1 - electric_refrigerator.n.01\n        grape.n.01_1 grape.n.01_2 grape.n.01_3 grape.n.01_4 - grape.n.01\n        peach.n.03_1 peach.n.03_2 - peach.n.03\n        pop.n.02_1 pop.n.02_2 - pop.n.02\n        beer.n.01_1 beer.n.01_2 - beer.n.01\n        water.n.06_1 water.n.06_2 water.n.06_3 water.n.06_4 - water.n.06\n        sink.n.01_1 - sink.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (onfloor carton.n.02_2 floor.n.01_2) \n        (onfloor carton.n.02_3 floor.n.01_2) \n        (inside chip.n.04_1 cabinet.n.01_1) \n        (inside chip.n.04_2 cabinet.n.01_1) \n        (ontop sandwich.n.01_1 countertop.n.01_1) \n        (ontop sandwich.n.01_2 countertop.n.01_1) \n        (ontop sandwich.n.01_3 countertop.n.01_1) \n        (ontop sandwich.n.01_4 countertop.n.01_1) \n        (ontop melon.n.01_1 countertop.n.01_1) \n        (inside strawberry.n.01_1 electric_refrigerator.n.01_1) \n        (inside strawberry.n.01_2 electric_refrigerator.n.01_1) \n        (inside strawberry.n.01_3 electric_refrigerator.n.01_1) \n        (inside strawberry.n.01_4 electric_refrigerator.n.01_1) \n        (inside grape.n.01_1 electric_refrigerator.n.01_1) \n        (inside grape.n.01_2 electric_refrigerator.n.01_1) \n        (inside grape.n.01_3 electric_refrigerator.n.01_1) \n        (inside grape.n.01_4 electric_refrigerator.n.01_1) \n        (inside peach.n.03_1 electric_refrigerator.n.01_1) \n        (inside peach.n.03_2 electric_refrigerator.n.01_1) \n        (inside pop.n.02_1 electric_refrigerator.n.01_1) \n        (inside pop.n.02_2 electric_refrigerator.n.01_1) \n        (inside beer.n.01_1 electric_refrigerator.n.01_1) \n        (inside beer.n.01_2 electric_refrigerator.n.01_1) \n        (inside water.n.06_1 cabinet.n.01_1) \n        (inside water.n.06_2 cabinet.n.01_1) \n        (inside water.n.06_3 cabinet.n.01_1) \n        (inside water.n.06_4 cabinet.n.01_1) \n        (inroom floor.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom floor.n.01_2 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (exists \n                (?carton.n.02 - carton.n.02) \n                (and \n                    (forall \n                        (?chip.n.04 - chip.n.04) \n                        (inside ?chip.n.04 ?carton.n.02)\n                    ) \n                    (forall \n                        (?sandwich.n.01 - sandwich.n.01) \n                        (inside ?sandwich.n.01 ?carton.n.02)\n                    )\n                )\n            ) \n            (exists \n                (?carton.n.02 - carton.n.02) \n                (and \n                    (forall \n                        (?strawberry.n.01 - strawberry.n.01) \n                        (inside ?strawberry.n.01 ?carton.n.02)\n                    ) \n                    (forall \n                        (?grape.n.01 - grape.n.01) \n                        (inside ?grape.n.01 ?carton.n.02)\n                    ) \n                    (forall \n                        (?peach.n.03 - peach.n.03) \n                        (inside ?peach.n.03 ?carton.n.02)\n                    ) \n                    (nextto ?melon.n.01_1 ?carton.n.02)\n                )\n            ) \n            (exists \n                (?carton.n.02 - carton.n.02) \n                (and \n                    (forall \n                        (?pop.n.02 - pop.n.02) \n                        (inside ?pop.n.02 ?carton.n.02)\n                    ) \n                    (forall \n                        (?beer.n.01 - beer.n.01) \n                        (inside ?beer.n.01 ?carton.n.02)\n                    ) \n                    (forall \n                        (?water.n.06 - water.n.06) \n                        (inside ?water.n.06 ?carton.n.02)\n                    )\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "picking_up_take-out_food_0_Ihlen_1_int_0_2021-06-10_22-09-43",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem picking_up_take-out_food_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \tcarton.n.02_1 - carton.n.02\n        table.n.02_1 - table.n.02\n        sushi.n.01_1 - sushi.n.01\n        hamburger.n.01_1 - hamburger.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (inside sushi.n.01_1 carton.n.02_1) \n        (inside hamburger.n.01_1 carton.n.02_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom table.n.02_1 dining_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?carton.n.02 - carton.n.02) \n                (ontop ?carton.n.02 ?table.n.02_1)\n            ) \n            (inside ?sushi.n.01_1 ?carton.n.02_1) \n            (inside ?hamburger.n.01_1 ?carton.n.02_1)\n        )\n    )\n)\n\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "picking_up_trash_0_Beechwood_0_int_1_2021-10-26_14-06-49",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem picking_up_trash_0)\n    (:domain igibson)\n\n    (:objects\n        ashcan.n.01_1 - ashcan.n.01\n        pad.n.01_1 pad.n.01_2 pad.n.01_3 - pad.n.01\n        pop.n.02_1 pop.n.02_2 - pop.n.02\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor ashcan.n.01_1 floor.n.01_2) \n        (onfloor pad.n.01_1 floor.n.01_2) \n        (onfloor pad.n.01_2 floor.n.01_2) \n        (onfloor pad.n.01_3 floor.n.01_1) \n        (onfloor pop.n.02_1 floor.n.01_1) \n        (onfloor pop.n.02_2 floor.n.01_1) \n        (inroom floor.n.01_2 kitchen) \n        (inroom floor.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?pad.n.01 - pad.n.01) \n                (inside ?pad.n.01 ?ashcan.n.01_1)\n            ) \n            (forall \n                (?pop.n.02 - pop.n.02) \n                (inside ?pop.n.02 ?ashcan.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "polishing_furniture_0_Ihlen_0_int_0_2021-10-26_11-35-40",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem polishing_furniture_0)\n    (:domain igibson)\n\n    (:objects\n     \tshelf.n.01_1 - shelf.n.01\n    \ttable.n.02_1 - table.n.02\n    \trag.n.01_1 - rag.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty shelf.n.01_1) \n        (dusty table.n.02_1) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom table.n.02_1 living_room) \n        (inroom shelf.n.01_1 living_room) \n        (inroom floor.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?table.n.02_1)\n            ) \n            (not \n                (dusty ?shelf.n.01_1)\n            ) \n            (under ?rag.n.01_1 ?table.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_under)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "polishing_shoes_0_Wainscott_0_int_0_2021-06-10_21-28-31",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem polishing_shoes_0)\n    (:domain igibson)\n\n    (:objects\n    \tshoe.n.01_1 shoe.n.01_2 - shoe.n.01\n    \trag.n.01_1 - rag.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (stained shoe.n.01_1) \n        (stained shoe.n.01_2) \n        (onfloor rag.n.01_1 floor.n.01_1) \n        (not \n            (soaked rag.n.01_1)\n        ) \n        (onfloor shoe.n.01_1 floor.n.01_1) \n        (onfloor shoe.n.01_2 floor.n.01_1) \n        (inroom sink.n.01_1 bathroom) \n        (inroom floor.n.01_1 bathroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (nextto ?rag.n.01_1 ?sink.n.01_1) \n            (soaked ?rag.n.01_1) \n            (and \n                (not \n                    (stained ?shoe.n.01_1)\n                ) \n                (not \n                    (stained ?shoe.n.01_2)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "polishing_silver_0_Merom_1_int_0_2021-10-26_11-43-15",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem polishing_silver_0)\n    (:domain igibson)\n\n    (:objects\n     \tspoon.n.01_1 spoon.n.01_2 spoon.n.01_3 spoon.n.01_4 - spoon.n.01\n    \trag.n.01_1 - rag.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty spoon.n.01_1) \n        (dusty spoon.n.01_2) \n        (dusty spoon.n.01_3) \n        (dusty spoon.n.01_4) \n        (inside rag.n.01_1 cabinet.n.01_1) \n        (inside spoon.n.01_1 cabinet.n.01_1) \n        (inside spoon.n.01_2 cabinet.n.01_1) \n        (inside spoon.n.01_3 cabinet.n.01_1) \n        (inside spoon.n.01_4 cabinet.n.01_1) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?spoon.n.01_1)\n            ) \n            (not \n                (dusty ?spoon.n.01_2)\n            ) \n            (not \n                (dusty ?spoon.n.01_3)\n            ) \n            (not \n                (dusty ?spoon.n.01_4)\n            ) \n            (not \n                (inside ?rag.n.01_1 ?cabinet.n.01_1)\n            ) \n            (inside ?spoon.n.01_1 ?cabinet.n.01_1) \n            (inside ?spoon.n.01_2 ?cabinet.n.01_1) \n            (inside ?spoon.n.01_3 ?cabinet.n.01_1) \n            (inside ?spoon.n.01_4 ?cabinet.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "preparing_a_shower_for_child_0_Ihlen_0_int_0_2021-10-25_21-36-25",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem preparing_a_shower_for_child_0)\n    (:domain igibson)\n\n    (:objects\n     \tshampoo.n.01_1 - shampoo.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \ttowel.n.01_1 - towel.n.01\n    \tshower.n.01_1 - shower.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor shampoo.n.01_1 floor.n.01_1) \n        (onfloor soap.n.01_1 floor.n.01_1) \n        (onfloor towel.n.01_1 floor.n.01_1) \n        (inroom shower.n.01_1 bathroom) \n        (inroom floor.n.01_1 bathroom) \n        (inroom sink.n.01_1 bathroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (onfloor ?towel.n.01_1 ?floor.n.01_1) \n            (onfloor ?shampoo.n.01_1 ?floor.n.01_1) \n            (nextto ?soap.n.01_1 ?sink.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "preparing_salad_0_Pomaria_1_int_1_2021-10-26_14-17-24",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem preparing_salad_0)\n    (:domain igibson)\n\n    (:objects\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tlettuce.n.03_1 lettuce.n.03_2 - lettuce.n.03\n    \tcountertop.n.01_1 - countertop.n.01\n    \tapple.n.01_1 apple.n.01_2 - apple.n.01\n    \ttomato.n.01_1 tomato.n.01_2 - tomato.n.01\n    \tradish.n.01_1 radish.n.01_2 - radish.n.01\n       carving_knife.n.01_1 - carving_knife.n.01 \n    \tplate.n.04_1 plate.n.04_2 - plate.n.04\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop lettuce.n.03_1 countertop.n.01_1) \n        (ontop lettuce.n.03_2 countertop.n.01_1) \n        (ontop apple.n.01_1 countertop.n.01_1) \n        (ontop apple.n.01_2 countertop.n.01_1) \n        (inside tomato.n.01_1 electric_refrigerator.n.01_1) \n        (inside tomato.n.01_2 electric_refrigerator.n.01_1) \n        (ontop radish.n.01_1 countertop.n.01_1) \n        (ontop radish.n.01_2 countertop.n.01_1) \n        (inside plate.n.04_1 cabinet.n.01_1) \n        (not \n            (dusty plate.n.04_1)\n        ) \n        (inside plate.n.04_2 cabinet.n.01_1) \n        (not \n            (dusty plate.n.04_2)\n        ) \n        (inside carving_knife.n.01_1 cabinet.n.01_1) \n        (inroom sink.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forpairs \n                (?lettuce.n.03 - lettuce.n.03) \n                (?plate.n.04 - plate.n.04) \n                (ontop ?lettuce.n.03 ?plate.n.04)\n            ) \n            (forpairs \n                (?apple.n.01 - apple.n.01) \n                (?plate.n.04 - plate.n.04) \n                (and \n                    (sliced ?apple.n.01) \n                    (ontop ?apple.n.01 ?plate.n.04)\n                )\n            ) \n            (forpairs \n                (?tomato.n.01 - tomato.n.01) \n                (?plate.n.04 - plate.n.04) \n                (and \n                    (ontop ?tomato.n.01 ?plate.n.04) \n                    (sliced ?tomato.n.01)\n                )\n            ) \n            (forpairs \n                (?radish.n.01 - radish.n.01) \n                (?plate.n.04 - plate.n.04) \n                (ontop ?radish.n.01 ?plate.n.04)\n            )\n        )\n    )\n)\n\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action slice)\n:parameters (?obj - object ?knife - carving_knife.n.01 ?board - countertop.n.01 ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "preserving_food_0_Rs_int_0_2021-08-25_15-53-33",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem preserving_food_0)\n    (:domain igibson)\n\n    (:objects \n        strawberry.n.01_1 strawberry.n.01_2 - strawberry.n.01\n        beef.n.02_1 - beef.n.02\n        jar.n.01_1 - jar.n.01\n        pan.n.01_1 - pan.n.01\n        electric_refrigerator.n.01_1 - electric_refrigerator.n.01\n        cabinet.n.01_1 - cabinet.n.01\n        countertop.n.01_1 - countertop.n.01\n        carving_knife.n.01_1 - carving_knife.n.01\n        floor.n.01_1 - floor.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop strawberry.n.01_1 countertop.n.01_1) \n        (ontop strawberry.n.01_2 countertop.n.01_1) \n        (ontop beef.n.02_1 countertop.n.01_1) \n        (ontop jar.n.01_1 countertop.n.01_1) \n        (open jar.n.01_1) \n        (ontop pan.n.01_1 countertop.n.01_1) \n        (ontop carving_knife.n.01_1 countertop.n.01_1) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?strawberry.n.01 - strawberry.n.01) \n                (sliced ?strawberry.n.01)\n            ) \n            (forall \n                (?strawberry.n.01 - strawberry.n.01) \n                (cooked ?strawberry.n.01)\n            ) \n            (forall \n                (?strawberry.n.01 - strawberry.n.01) \n                (inside ?strawberry.n.01 ?jar.n.01_1)\n            ) \n            (not \n                (open ?jar.n.01_1)\n            ) \n            (inside ?beef.n.02_1 ?electric_refrigerator.n.01_1) \n            (frozen ?beef.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action slice)\n:parameters (?obj - object ?knife - carving_knife.n.01 ?board - countertop.n.01 ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action cook)\n:parameters (?obj - object ?pan - pan.n.01)\n:precondition ()\n:effect ()\n)\n(:action freeze)\n:parameters (?obj - object ?fridge - electric_refrigerator.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "putting_away_Christmas_decorations_0_Wainscott_0_int_0_2021-06-06_17-03-25",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem putting_away_Christmas_decorations_0)\n    (:domain igibson)\n\n    (:objects\n     \twreath.n.01_1 wreath.n.01_2 - wreath.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tbow.n.08_1 bow.n.08_2 bow.n.08_3 - bow.n.08\n    \tribbon.n.01_1 ribbon.n.01_2 ribbon.n.01_3 - ribbon.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor wreath.n.01_1 floor.n.01_1) \n        (onfloor wreath.n.01_2 floor.n.01_1) \n        (onfloor bow.n.08_1 floor.n.01_1) \n        (onfloor bow.n.08_2 floor.n.01_1) \n        (onfloor bow.n.08_3 floor.n.01_1) \n        (onfloor ribbon.n.01_1 floor.n.01_1) \n        (onfloor ribbon.n.01_2 floor.n.01_1) \n        (onfloor ribbon.n.01_3 floor.n.01_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom cabinet.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?wreath.n.01 - wreath.n.01) \n                (nextto ?wreath.n.01 ?cabinet.n.01_1)\n            ) \n            (forall \n                (?bow.n.08 - bow.n.08) \n                (nextto ?bow.n.08 ?cabinet.n.01_1)\n            ) \n            (forall \n                (?ribbon.n.01 - ribbon.n.01) \n                (inside ?ribbon.n.01 ?cabinet.n.01_1)\n            )\n        )\n    )\n)\n\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "putting_away_Halloween_decorations_0_Rs_int_0_2021-10-25_22-42-17",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem putting_away_Halloween_decorations_0)\n    (:domain igibson)\n\n    (:objects\n     \tpumpkin.n.02_1 pumpkin.n.02_2 - pumpkin.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tcaldron.n.01_1 - caldron.n.01\n    \tsheet.n.03_1 - sheet.n.03\n    \ttable.n.02_1 - table.n.02\n    \tcandle.n.01_1 candle.n.01_2 candle.n.01_3 - candle.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tsofa.n.01_1 - sofa.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor pumpkin.n.02_1 floor.n.01_1) \n        (onfloor pumpkin.n.02_2 floor.n.01_1) \n        (onfloor caldron.n.01_1 floor.n.01_1) \n        (ontop sheet.n.03_1 table.n.02_1) \n        (onfloor candle.n.01_1 floor.n.01_1) \n        (onfloor candle.n.01_2 floor.n.01_1) \n        (onfloor candle.n.01_3 floor.n.01_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom cabinet.n.01_1 living_room) \n        (inroom table.n.02_1 living_room) \n        (inroom sofa.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?pumpkin.n.02 - pumpkin.n.02) \n                (inside ?pumpkin.n.02 ?cabinet.n.01_1)\n            ) \n            (forall \n                (?candle.n.01 - candle.n.01) \n                (inside ?candle.n.01 ?cabinet.n.01_1)\n            ) \n            (or \n                (nextto ?sheet.n.03_1 ?table.n.02_1) \n                (ontop ?sheet.n.03_1 ?table.n.02_1)\n            ) \n            (nextto ?caldron.n.01_1 ?table.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "putting_away_toys_0_Ihlen_0_int_0_2021-10-25_22-47-44",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem putting_away_toys_0)\n    (:domain igibson)\n\n    (:objects\n        plaything.n.01_1 plaything.n.01_2 plaything.n.01_3 plaything.n.01_4 plaything.n.01_5 plaything.n.01_6 plaything.n.01_7 plaything.n.01_8 - plaything.n.01\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        carton.n.02_1 carton.n.02_2 - carton.n.02\n        agent.n.01_1 - agent.n.01\n        table.n.02_1 - table.n.02\n    )\n    \n    (:init \n        (onfloor plaything.n.01_1 floor.n.01_1) \n        (onfloor plaything.n.01_2 floor.n.01_1) \n        (onfloor plaything.n.01_3 floor.n.01_1) \n        (onfloor plaything.n.01_4 floor.n.01_1) \n        (onfloor plaything.n.01_5 floor.n.01_2) \n        (onfloor plaything.n.01_6 floor.n.01_2) \n        (onfloor plaything.n.01_7 floor.n.01_2) \n        (onfloor plaything.n.01_8 floor.n.01_2) \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (ontop carton.n.02_2 table.n.02_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom floor.n.01_2 dining_room) \n        (inroom table.n.02_1 dining_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?plaything.n.01 - plaything.n.01) \n                (exists \n                    (?carton.n.02 - carton.n.02) \n                    (inside ?plaything.n.01 ?carton.n.02)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "putting_dishes_away_after_cleaning_0_Ihlen_1_int_0_2021-10-25_22-54-09",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem putting_dishes_away_after_cleaning_0)\n    (:domain igibson)\n\n    (:objects\n     \tplate.n.04_1 plate.n.04_2 plate.n.04_3 plate.n.04_4 plate.n.04_5 plate.n.04_6 plate.n.04_7 plate.n.04_8 - plate.n.04\n    \tcountertop.n.01_1 countertop.n.01_2 - countertop.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop plate.n.04_1 countertop.n.01_1) \n        (ontop plate.n.04_2 countertop.n.01_1) \n        (ontop plate.n.04_3 countertop.n.01_1) \n        (ontop plate.n.04_4 countertop.n.01_1) \n        (ontop plate.n.04_5 countertop.n.01_2) \n        (ontop plate.n.04_6 countertop.n.01_2) \n        (ontop plate.n.04_7 countertop.n.01_2) \n        (ontop plate.n.04_8 countertop.n.01_2) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom countertop.n.01_2 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (exists \n                (?cabinet.n.01 - cabinet.n.01) \n                (forall \n                    (?plate.n.04 - plate.n.04) \n                    (inside ?plate.n.04 ?cabinet.n.01_1)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "putting_leftovers_away_0_Ihlen_1_int_0_2021-06-08_13-42-57",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem putting_leftovers_away_0)\n    (:domain igibson)\n\n    (:objects\n     \tpasta.n.02_1 pasta.n.02_2 pasta.n.02_3 pasta.n.02_4 - pasta.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tsauce.n.01_1 sauce.n.01_2 sauce.n.01_3 sauce.n.01_4 - sauce.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop pasta.n.02_1 countertop.n.01_1) \n        (ontop pasta.n.02_2 countertop.n.01_1) \n        (ontop pasta.n.02_3 countertop.n.01_1) \n        (ontop pasta.n.02_4 countertop.n.01_1) \n        (ontop sauce.n.01_1 countertop.n.01_1) \n        (ontop sauce.n.01_2 countertop.n.01_1) \n        (ontop sauce.n.01_3 countertop.n.01_1) \n        (ontop sauce.n.01_4 countertop.n.01_1) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?pasta.n.02 - pasta.n.02) \n                (inside ?pasta.n.02 ?electric_refrigerator.n.01_1)\n            ) \n            (forall \n                (?sauce.n.01 - sauce.n.01) \n                (inside ?sauce.n.01 ?electric_refrigerator.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "putting_up_Christmas_decorations_inside_0_Ihlen_1_int_0_2021-06-03_14-27-09",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem putting_up_Christmas_decorations_inside_0)\n    (:domain igibson)\n\n    (:objects \n        christmas_tree.n.05_1 - christmas_tree.n.05\n        wreath.n.01_1 - wreath.n.01\n        bow.n.08_1 bow.n.08_2 bow.n.08_3 - bow.n.08\n        candle.n.01_1 candle.n.01_2 - candle.n.01\n        wrapping.n.01_1 wrapping.n.01_2 wrapping.n.01_3 - wrapping.n.01\n        carton.n.02_1 - carton.n.02\n        floor.n.01_1 - floor.n.01\n        table.n.02_1 - table.n.02\n        sofa.n.01_1 - sofa.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor christmas_tree.n.05_1 floor.n.01_1)\n        (onfloor carton.n.02_1 floor.n.01_1)\n        (inside wreath.n.01_1 carton.n.02_1)\n        (inside bow.n.08_1 carton.n.02_1)\n        (inside bow.n.08_2 carton.n.02_1)\n        (inside bow.n.08_3 carton.n.02_1)\n        (inside candle.n.01_1 carton.n.02_1)\n        (inside candle.n.01_2 carton.n.02_1)\n        (onfloor wrapping.n.01_1 floor.n.01_1)\n        (onfloor wrapping.n.01_2 floor.n.01_1)\n        (onfloor wrapping.n.01_3 floor.n.01_1)\n        (inroom floor.n.01_1 living_room)\n        (inroom table.n.02_1 dining_room)\n        (inroom sofa.n.01_1 living_room)\n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?wrapping.n.01 - wrapping.n.01)\n                (or \n                    (nextto ?wrapping.n.01 ?christmas_tree.n.05_1)\n                    (under ?wrapping.n.01 ?christmas_tree.n.05_1)\n                )\n            )\n            (forall \n                (?candle.n.01 - candle.n.01)\n                (ontop ?candle.n.01 ?table.n.02_1)\n            )\n            (forn \n                (1)\n                (?bow.n.08 - bow.n.08)\n                (ontop ?bow.n.08 ?table.n.02_1)\n            )\n            (forn\n                (2)\n                (?bow.n.08 - bow.n.08)\n                (ontop ?bow.n.08 ?sofa.n.01_1)\n            )\n            (ontop ?wreath.n.01_1 ?table.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "re-shelving_library_books_0_Rs_int_0_2021-10-25_21-22-26",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem re-shelving_library_books_0)\n    (:domain igibson)\n\n    (:objects\n     \tbook.n.02_1 book.n.02_2 book.n.02_3 book.n.02_4 book.n.02_5 book.n.02_6 book.n.02_7 book.n.02_8 - book.n.02\n    \ttable.n.02_1 - table.n.02\n    \tshelf.n.01_1 - shelf.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop book.n.02_1 table.n.02_1) \n        (ontop book.n.02_2 table.n.02_1) \n        (ontop book.n.02_3 table.n.02_1) \n        (ontop book.n.02_4 table.n.02_1) \n        (ontop book.n.02_5 table.n.02_1) \n        (ontop book.n.02_6 table.n.02_1) \n        (ontop book.n.02_7 table.n.02_1) \n        (ontop book.n.02_8 table.n.02_1) \n        (inroom table.n.02_1 living_room) \n        (inroom shelf.n.01_1 living_room) \n        (inroom floor.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (ontop ?book.n.02_1 ?shelf.n.01_1) \n            (ontop ?book.n.02_2 ?shelf.n.01_1) \n            (ontop ?book.n.02_3 ?shelf.n.01_1) \n            (ontop ?book.n.02_4 ?shelf.n.01_1) \n            (ontop ?book.n.02_5 ?table.n.02_1) \n            (ontop ?book.n.02_6 ?table.n.02_1) \n            (ontop ?book.n.02_7 ?table.n.02_1) \n            (ontop ?book.n.02_8 ?table.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "rearranging_furniture_0_Pomaria_2_int_1_2021-06-22_16-39-21",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem rearranging_furniture_0)\n    (:domain igibson)\n\n    (:objects\n     \tlamp.n.02_1 lamp.n.02_2 - lamp.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tseat.n.03_1 seat.n.03_2 - seat.n.03\n    \tbed.n.01_1 - bed.n.01\n    \twindow.n.01_1 - window.n.01\n    \tdoor.n.01_1 - door.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor lamp.n.02_1 floor.n.01_1) \n        (onfloor lamp.n.02_2 floor.n.01_1) \n        (onfloor seat.n.03_1 floor.n.01_1) \n        (ontop seat.n.03_2 bed.n.01_1) \n        (inroom window.n.01_1 bedroom) \n        (inroom bed.n.01_1 bedroom) \n        (inroom floor.n.01_1 bedroom) \n        (inroom door.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (nextto ?lamp.n.02_1 ?door.n.01_1) \n            (nextto ?lamp.n.02_2 ?window.n.01_1) \n            (nextto ?seat.n.03_2 ?window.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "serving_a_meal_0_Merom_1_int_0_2021-10-26_00-34-17",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem serving_a_meal_0)\n    (:domain igibson)\n\n    (:objects\n     \tchicken.n.01_1 chicken.n.01_2 - chicken.n.01\n    \tknife.n.01_1 knife.n.01_2 - knife.n.01\n    \tfork.n.01_1 fork.n.01_2 - fork.n.01\n    \tspoon.n.01_1 spoon.n.01_2 - spoon.n.01\n    \tplate.n.04_1 plate.n.04_2 - plate.n.04\n    \tsoup.n.01_1 soup.n.01_2 - soup.n.01\n    \ttable.n.02_1 - table.n.02\n    \tbread.n.01_1 bread.n.01_2 - bread.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tsalad.n.01_1 salad.n.01_2 - salad.n.01\n    \twater.n.06_1 water.n.06_2 - water.n.06\n    \tcake.n.03_1 cake.n.03_2 - cake.n.03\n    \tstove.n.01_1 - stove.n.01\n            cabinet.n.01_1 cabinet.n.01_2 - cabinet.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (cooked chicken.n.01_1) \n        (cooked chicken.n.01_2) \n        (inside knife.n.01_1 cabinet.n.01_1) \n        (inside knife.n.01_2 cabinet.n.01_1) \n        (inside fork.n.01_1 cabinet.n.01_1) \n        (inside fork.n.01_2 cabinet.n.01_1) \n        (inside spoon.n.01_1 cabinet.n.01_1) \n        (inside spoon.n.01_2 cabinet.n.01_1) \n        (inside plate.n.04_1 cabinet.n.01_2) \n        (inside plate.n.04_2 cabinet.n.01_1) \n        (ontop soup.n.01_1 table.n.02_1) \n        (ontop soup.n.01_2 table.n.02_1) \n        (inside bread.n.01_2 electric_refrigerator.n.01_1) \n        (inside bread.n.01_1 electric_refrigerator.n.01_1) \n        (inside salad.n.01_1 electric_refrigerator.n.01_1) \n        (inside salad.n.01_2 electric_refrigerator.n.01_1) \n        (inside chicken.n.01_1 electric_refrigerator.n.01_1) \n        (inside chicken.n.01_2 electric_refrigerator.n.01_1) \n        (inside water.n.06_1 electric_refrigerator.n.01_1) \n        (inside water.n.06_2 electric_refrigerator.n.01_1) \n        (inside cake.n.03_1 electric_refrigerator.n.01_1) \n        (inside cake.n.03_2 electric_refrigerator.n.01_1) \n        (inroom table.n.02_1 dining_room) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom stove.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom cabinet.n.01_2 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?plate.n.04 - plate.n.04) \n                (ontop ?plate.n.04 ?table.n.02_1)\n            ) \n            (forall \n                (?knife.n.01 - knife.n.01) \n                (ontop ?knife.n.01 ?table.n.02_1)\n            ) \n            (forall \n                (?fork.n.01 - fork.n.01) \n                (ontop ?fork.n.01 ?table.n.02_1)\n            ) \n            (forpairs \n                (?spoon.n.01 - spoon.n.01) \n                (?soup.n.01 - soup.n.01) \n                (nextto ?spoon.n.01 ?soup.n.01)\n            ) \n            (forall \n                (?water.n.06 - water.n.06) \n                (ontop ?water.n.06 ?table.n.02_1)\n            ) \n            (forpairs \n                (?chicken.n.01 - chicken.n.01) \n                (?plate.n.04 - plate.n.04) \n                (ontop ?chicken.n.01 ?plate.n.04)\n            ) \n            (forpairs \n                (?salad.n.01 - salad.n.01) \n                (?plate.n.04 - plate.n.04) \n                (nextto ?salad.n.01 ?plate.n.04)\n            ) \n            (forpairs \n                (?bread.n.01 - bread.n.01) \n                (?plate.n.04 - plate.n.04) \n                (nextto ?bread.n.01 ?plate.n.04)\n            ) \n            (forpairs \n                (?cake.n.03 - cake.n.03) \n                (?plate.n.04 - plate.n.04) \n                (nextto ?cake.n.03 ?plate.n.04)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "serving_hors_d_oeuvres_0_Wainscott_0_int_0_2021-10-26_14-00-22",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem serving_hors_d_oeuvres_0)\n    (:domain igibson)\n\n    (:objects\n        cabinet.n.01_1 - cabinet.n.01\n    \tsalad.n.01_1 salad.n.01_2 salad.n.01_3 salad.n.01_4 - salad.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \ttray.n.01_1 - tray.n.01\n    \tparsley.n.02_1 parsley.n.02_2 parsley.n.02_3 parsley.n.02_4 - parsley.n.02\n    \tcracker.n.01_1 cracker.n.01_2 cracker.n.01_3 cracker.n.01_4 - cracker.n.01\n    \ttable.n.02_1 - table.n.02\n    \tcheese.n.01_1 cheese.n.01_2 cheese.n.01_3 cheese.n.01_4 - cheese.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (inside salad.n.01_1 electric_refrigerator.n.01_1) \n        (inside salad.n.01_2 electric_refrigerator.n.01_1) \n        (inside salad.n.01_3 electric_refrigerator.n.01_1) \n        (inside salad.n.01_4 electric_refrigerator.n.01_1) \n        (inside parsley.n.02_1 electric_refrigerator.n.01_1) \n        (inside parsley.n.02_2 electric_refrigerator.n.01_1) \n        (inside parsley.n.02_3 electric_refrigerator.n.01_1) \n        (inside parsley.n.02_4 electric_refrigerator.n.01_1) \n        (onfloor tray.n.01_1 floor.n.01_1) \n        (ontop cracker.n.01_1 table.n.02_1) \n        (ontop cracker.n.01_2 table.n.02_1) \n        (ontop cracker.n.01_3 table.n.02_1) \n        (ontop cracker.n.01_4 table.n.02_1) \n        (inside cheese.n.01_1 electric_refrigerator.n.01_1) \n        (inside cheese.n.01_2 electric_refrigerator.n.01_1) \n        (inside cheese.n.01_3 electric_refrigerator.n.01_1) \n        (inside cheese.n.01_4 electric_refrigerator.n.01_1) \n        (inroom table.n.02_1 dining_room) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 dining_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (ontop ?tray.n.01_1 ?table.n.02_1) \n            (forall \n                (?cracker.n.01 - cracker.n.01) \n                (ontop ?cracker.n.01 ?table.n.02_1)\n            ) \n            (forpairs \n                (?salad.n.01 - salad.n.01)\n                (?cracker.n.01 - cracker.n.01)\n                (nextto ?salad.n.01 ?cracker.n.01)\n            )\n            (forpairs \n                (?cheese.n.01 - cheese.n.01) \n                (?parsley.n.02 - parsley.n.02) \n                (ontop ?parsley.n.02 ?cheese.n.01)\n            ) \n        )\n    )\n)\n\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "setting_mousetraps_0_Beechwood_1_int_0_2021-10-26_13-53-26",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem setting_mousetraps_0)\n    (:domain igibson)\n\n    (:objects\n     \tmousetrap.n.01_1 mousetrap.n.01_2 mousetrap.n.01_3 mousetrap.n.01_4 - mousetrap.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \ttoilet.n.02_1 - toilet.n.02\n        bed.n.01_1 - bed.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop mousetrap.n.01_1 bed.n.01_1) \n        (ontop mousetrap.n.01_2 bed.n.01_1) \n        (ontop mousetrap.n.01_3 bed.n.01_1) \n        (ontop mousetrap.n.01_4 bed.n.01_1) \n        (inroom floor.n.01_1 corridor) \n        (inroom toilet.n.02_1 bathroom) \n        (inroom sink.n.01_1 bathroom) \n        (inroom floor.n.01_2 bathroom) \n        (inroom bed.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (onfloor ?mousetrap.n.01_1 ?floor.n.01_1) \n            (onfloor ?mousetrap.n.01_2 ?floor.n.01_1) \n            (nextto ?mousetrap.n.01_3 ?toilet.n.02_1) \n            (nextto ?mousetrap.n.01_4 ?toilet.n.02_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "setting_up_candles_0_Wainscott_0_int_0_2021-10-26_13-40-51",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem setting_up_candles_0)\n    (:domain igibson)\n\n    (:objects\n        candle.n.01_1 candle.n.01_2 candle.n.01_3 candle.n.01_4 candle.n.01_5 candle.n.01_6 - candle.n.01\n        table.n.02_1 table.n.02_2 - table.n.02\n        floor.n.01_1 floor.n.01_2 - floor.n.01\n        carton.n.02_1 carton.n.02_2 - carton.n.02\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (onfloor carton.n.02_2 floor.n.01_1) \n        (inside candle.n.01_1 carton.n.02_1) \n        (inside candle.n.01_2 carton.n.02_1) \n        (inside candle.n.01_3 carton.n.02_1) \n        (inside candle.n.01_4 carton.n.02_2) \n        (inside candle.n.01_5 carton.n.02_2) \n        (inside candle.n.01_6 carton.n.02_2) \n        (inroom floor.n.01_1 living_room) \n        (inroom floor.n.01_2 dining_room) \n        (inroom table.n.02_1 living_room) \n        (inroom table.n.02_2 dining_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forn \n                (3) \n                (?candle.n.01 - candle.n.01) \n                (ontop ?candle.n.01 ?table.n.02_1)\n            ) \n            (forn \n                (3) \n                (?candle.n.01 - candle.n.01) \n                (ontop ?candle.n.01 ?table.n.02_2)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "sorting_books_0_Pomaria_1_int_0_2021-10-26_13-27-18",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem sorting_books_0)\n    (:domain igibson)\n\n    (:objects\n     \thardback.n.01_1 hardback.n.01_2 - hardback.n.01\n    \ttable.n.02_1 - table.n.02\n    \tfloor.n.01_1 - floor.n.01\n    \tshelf.n.01_1 - shelf.n.01\n    \tbook.n.02_1 book.n.02_2 - book.n.02\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop hardback.n.01_1 table.n.02_1) \n        (onfloor hardback.n.01_2 floor.n.01_1) \n        (onfloor book.n.02_1 floor.n.01_1) \n        (ontop book.n.02_2 table.n.02_1) \n        (inroom table.n.02_1 living_room) \n        (inroom shelf.n.01_1 living_room) \n        (inroom floor.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?hardback.n.01 - hardback.n.01) \n                (ontop ?hardback.n.01 ?shelf.n.01_1)\n            ) \n            (forall \n                (?book.n.02 - book.n.02) \n                (ontop ?book.n.02 ?shelf.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "sorting_groceries_0_Wainscott_0_int_0_2021-10-26_13-36-01",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem sorting_groceries_0)\n    (:domain igibson)\n\n    (:objects\n     \tbread.n.01_1 - bread.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \tflour.n.01_1 - flour.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tmilk.n.01_1 - milk.n.01\n    \tchair.n.01_1 - chair.n.01\n    \tmeat.n.01_1 - meat.n.01\n    \ttable.n.02_1 - table.n.02\n    \tcheese.n.01_1 - cheese.n.01\n    \tyogurt.n.01_1 - yogurt.n.01\n    \tsoup.n.01_1 - soup.n.01\n    \tcarrot.n.03_1 carrot.n.03_2 carrot.n.03_3 - carrot.n.03\n    \tbroccoli.n.02_1 - broccoli.n.02\n    \tapple.n.01_1 apple.n.01_2 - apple.n.01\n    \torange.n.01_1 orange.n.01_2 orange.n.01_3 - orange.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop bread.n.01_1 countertop.n.01_1) \n        (onfloor flour.n.01_1 floor.n.01_1) \n        (ontop milk.n.01_1 chair.n.01_1) \n        (ontop meat.n.01_1 table.n.02_1) \n        (ontop cheese.n.01_1 table.n.02_1) \n        (ontop yogurt.n.01_1 table.n.02_1) \n        (ontop soup.n.01_1 table.n.02_1) \n        (ontop carrot.n.03_1 countertop.n.01_1) \n        (ontop carrot.n.03_2 countertop.n.01_1) \n        (ontop carrot.n.03_3 countertop.n.01_1) \n        (ontop broccoli.n.02_1 countertop.n.01_1) \n        (ontop apple.n.01_1 countertop.n.01_1) \n        (ontop apple.n.01_2 countertop.n.01_1) \n        (ontop orange.n.01_1 table.n.02_1) \n        (ontop orange.n.01_2 table.n.02_1) \n        (ontop orange.n.01_3 table.n.02_1) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom table.n.02_1 kitchen) \n        (inroom chair.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (inside ?bread.n.01_1 ?cabinet.n.01_1) \n            (inside ?flour.n.01_1 ?cabinet.n.01_1) \n            (and \n                (inside ?milk.n.01_1 ?electric_refrigerator.n.01_1) \n                (inside ?meat.n.01_1 ?electric_refrigerator.n.01_1) \n                (inside ?cheese.n.01_1 ?electric_refrigerator.n.01_1) \n                (inside ?yogurt.n.01_1 ?electric_refrigerator.n.01_1) \n                (inside ?soup.n.01_1 ?electric_refrigerator.n.01_1)\n            ) \n            (forall \n                (?carrot.n.03 - carrot.n.03) \n                (and \n                    (inside ?carrot.n.03 ?electric_refrigerator.n.01_1) \n                    (or \n                        (nextto ?carrot.n.03 ?carrot.n.03_1) \n                        (nextto ?carrot.n.03 ?carrot.n.03_2) \n                        (nextto ?carrot.n.03 ?carrot.n.03_3)\n                    )\n                )\n            ) \n            (inside ?broccoli.n.02_1 ?electric_refrigerator.n.01_1) \n            (forall \n                (?apple.n.01 - apple.n.01) \n                (and \n                    (inside ?apple.n.01 ?electric_refrigerator.n.01_1) \n                    (or \n                        (nextto ?apple.n.01 ?apple.n.01_1) \n                        (nextto ?apple.n.01 ?apple.n.01_2)\n                    )\n                )\n            ) \n            (forall \n                (?orange.n.01 - orange.n.01) \n                (and \n                    (ontop ?orange.n.01 ?table.n.02_1) \n                    (or \n                        (nextto ?orange.n.01 ?orange.n.01_1) \n                        (nextto ?orange.n.01 ?orange.n.01_2) \n                        (nextto ?orange.n.01 ?orange.n.01_3)\n                    )\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "sorting_mail_0_Wainscott_0_int_1_2021-10-26_14-38-16",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem sorting_mail_0)\n    (:domain igibson)\n\n    (:objects\n        envelope.n.01_1 envelope.n.01_2 envelope.n.01_3 envelope.n.01_4 - envelope.n.01\n        floor.n.01_1 - floor.n.01\n        sofa.n.01_1 - sofa.n.01\n        newspaper.n.03_1 newspaper.n.03_2 newspaper.n.03_3 newspaper.n.03_4 - newspaper.n.03\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor envelope.n.01_1 floor.n.01_1) \n        (onfloor envelope.n.01_2 floor.n.01_1) \n        (onfloor envelope.n.01_3 floor.n.01_1) \n        (onfloor envelope.n.01_4 floor.n.01_1) \n        (onfloor newspaper.n.03_1 floor.n.01_1) \n        (onfloor newspaper.n.03_2 floor.n.01_1) \n        (onfloor newspaper.n.03_3 floor.n.01_1) \n        (onfloor newspaper.n.03_4 floor.n.01_1) \n        (inroom sofa.n.01_1 living_room) \n        (inroom floor.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?envelope.n.01 - envelope.n.01) \n                (or \n                    (ontop ?envelope.n.01 ?envelope.n.01_1) \n                    (ontop ?envelope.n.01 ?envelope.n.01_2) \n                    (ontop ?envelope.n.01 ?envelope.n.01_3) \n                    (ontop ?envelope.n.01 ?envelope.n.01_4)\n                )\n            ) \n            (forall \n                (?newspaper.n.03 - newspaper.n.03) \n                (or \n                    (ontop ?newspaper.n.03 ?newspaper.n.03_1) \n                    (ontop ?newspaper.n.03 ?newspaper.n.03_2) \n                    (ontop ?newspaper.n.03 ?newspaper.n.03_3) \n                    (ontop ?newspaper.n.03 ?newspaper.n.03_4)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "storing_food_0_Rs_int_0_2021-10-25_21-27-36",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem storing_food_0)\n    (:domain igibson)\n\n    (:objects\n     \toatmeal.n.01_1 oatmeal.n.01_2 - oatmeal.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \tchip.n.04_1 chip.n.04_2 - chip.n.04\n    \tvegetable_oil.n.01_1 vegetable_oil.n.01_2 - vegetable_oil.n.01\n    \tsugar.n.01_1 sugar.n.01_2 - sugar.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop oatmeal.n.01_1 countertop.n.01_1) \n        (ontop oatmeal.n.01_2 countertop.n.01_1) \n        (ontop chip.n.04_1 countertop.n.01_1) \n        (ontop chip.n.04_2 countertop.n.01_1) \n        (ontop vegetable_oil.n.01_1 countertop.n.01_1) \n        (ontop vegetable_oil.n.01_2 countertop.n.01_1) \n        (ontop sugar.n.01_1 countertop.n.01_1) \n        (ontop sugar.n.01_2 countertop.n.01_1) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (inside ?oatmeal.n.01_1 ?cabinet.n.01_1) \n            (inside ?oatmeal.n.01_2 ?cabinet.n.01_1) \n            (inside ?chip.n.04_1 ?cabinet.n.01_1) \n            (inside ?chip.n.04_2 ?cabinet.n.01_1) \n            (inside ?vegetable_oil.n.01_1 ?cabinet.n.01_1) \n            (inside ?vegetable_oil.n.01_2 ?cabinet.n.01_1) \n            (inside ?sugar.n.01_1 ?cabinet.n.01_1) \n            (inside ?sugar.n.01_2 ?cabinet.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "storing_the_groceries_0_Beechwood_0_int_0_2021-10-26_13-13-47",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem storing_the_groceries_0)\n    (:domain igibson)\n\n    (:objects\n     \tcereal.n.03_1 cereal.n.03_2 - cereal.n.03\n    \tcountertop.n.01_1 - countertop.n.01\n    \tlettuce.n.03_1 lettuce.n.03_2 - lettuce.n.03\n    \tbroccoli.n.02_1 broccoli.n.02_2 - broccoli.n.02\n    \traspberry.n.02_1 raspberry.n.02_2 - raspberry.n.02\n    \tpork.n.01_1 pork.n.01_2 - pork.n.01\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tcabinet.n.01_1 - cabinet.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop cereal.n.03_1 countertop.n.01_1) \n        (ontop cereal.n.03_2 countertop.n.01_1) \n        (ontop lettuce.n.03_1 countertop.n.01_1) \n        (ontop lettuce.n.03_2 countertop.n.01_1) \n        (ontop broccoli.n.02_1 countertop.n.01_1) \n        (ontop broccoli.n.02_2 countertop.n.01_1) \n        (ontop raspberry.n.02_1 countertop.n.01_1) \n        (ontop raspberry.n.02_2 countertop.n.01_1) \n        (ontop pork.n.01_1 countertop.n.01_1) \n        (ontop pork.n.01_2 countertop.n.01_1) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (inside ?cereal.n.03_1 ?cabinet.n.01_1) \n            (inside ?cereal.n.03_2 ?cabinet.n.01_1) \n            (nextto ?cereal.n.03_1 ?cereal.n.03_2) \n            (inside ?lettuce.n.03_1 ?electric_refrigerator.n.01_1) \n            (inside ?lettuce.n.03_2 ?electric_refrigerator.n.01_1) \n            (nextto ?lettuce.n.03_1 ?lettuce.n.03_2) \n            (inside ?broccoli.n.02_1 ?electric_refrigerator.n.01_1) \n            (inside ?broccoli.n.02_2 ?electric_refrigerator.n.01_1) \n            (nextto ?broccoli.n.02_1 ?broccoli.n.02_2) \n            (inside ?raspberry.n.02_1 ?electric_refrigerator.n.01_1) \n            (inside ?raspberry.n.02_2 ?electric_refrigerator.n.01_1) \n            (nextto ?raspberry.n.02_1 ?raspberry.n.02_2) \n            (inside ?pork.n.01_1 ?electric_refrigerator.n.01_1) \n            (inside ?pork.n.01_2 ?electric_refrigerator.n.01_1) \n            (nextto ?pork.n.01_1 ?pork.n.01_2)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "thawing_frozen_food_0_Pomaria_1_int_0_2021-10-26_13-10-33",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem thawing_frozen_food_0)\n    (:domain igibson)\n\n    (:objects\n     \tdate.n.08_1 - date.n.08\n    \telectric_refrigerator.n.01_1 - electric_refrigerator.n.01\n    \tolive.n.04_1 - olive.n.04\n    \tfish.n.02_1 fish.n.02_2 fish.n.02_3 fish.n.02_4 - fish.n.02\n    \tsink.n.01_1 - sink.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (inside date.n.08_1 electric_refrigerator.n.01_1) \n        (inside olive.n.04_1 electric_refrigerator.n.01_1) \n        (inside fish.n.02_1 electric_refrigerator.n.01_1) \n        (inside fish.n.02_2 electric_refrigerator.n.01_1) \n        (inside fish.n.02_3 electric_refrigerator.n.01_1) \n        (inside fish.n.02_4 electric_refrigerator.n.01_1) \n        (frozen fish.n.02_1) \n        (frozen fish.n.02_2) \n        (frozen fish.n.02_3) \n        (frozen fish.n.02_4) \n        (frozen date.n.08_1) \n        (frozen olive.n.04_1) \n        (inroom sink.n.01_1 kitchen) \n        (inroom electric_refrigerator.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (nextto ?date.n.08_1 ?fish.n.02_1) \n            (nextto ?fish.n.02_1 ?sink.n.01_1) \n            (nextto ?fish.n.02_2 ?sink.n.01_1) \n            (nextto ?fish.n.02_3 ?sink.n.01_1) \n            (nextto ?fish.n.02_4 ?sink.n.01_1) \n            (nextto ?olive.n.04_1 ?sink.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "throwing_away_leftovers_0_Ihlen_1_int_0_2021-06-04_19-52-40",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem throwing_away_leftovers_0)\n    (:domain igibson)\n\n    (:objects\n     \tplate.n.04_1 plate.n.04_2 plate.n.04_3 plate.n.04_4 - plate.n.04\n        hamburger.n.01_1 hamburger.n.01_2 hamburger.n.01_3 - hamburger.n.01\n    \tcountertop.n.01_1 - countertop.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tashcan.n.01_1 - ashcan.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop plate.n.04_1 countertop.n.01_1) \n        (ontop hamburger.n.01_1 plate.n.04_1) \n        (ontop plate.n.04_2 countertop.n.01_1) \n        (ontop hamburger.n.01_3 plate.n.04_2) \n        (ontop plate.n.04_3 countertop.n.01_1) \n        (ontop hamburger.n.01_2 plate.n.04_3) \n        (ontop plate.n.04_4 countertop.n.01_1) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor ashcan.n.01_1 floor.n.01_1) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?hamburger.n.01 - hamburger.n.01) \n                (inside ?hamburger.n.01 ?ashcan.n.01_1)\n            )\n        )\n    )\n)\n\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "unpacking_suitcase_0_Benevolence_1_int_0_2021-06-08_17-58-34",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem unpacking_suitcase_0)\n    (:domain igibson)\n\n    (:objects\n     \tsock.n.01_1 sock.n.01_2 - sock.n.01\n    \tfloor.n.01_1 - floor.n.01\n        carton.n.02_1 - carton.n.02\n        perfume.n.02_1 - perfume.n.02\n        toothbrush.n.01_1 - toothbrush.n.01\n        notebook.n.01_1 - notebook.n.01\n    \tsofa.n.01_1 - sofa.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor carton.n.02_1 floor.n.01_1) \n        (inside sock.n.01_1 carton.n.02_1) \n        (inside sock.n.01_2 carton.n.02_1) \n        (inside perfume.n.02_1 carton.n.02_1) \n        (inside toothbrush.n.01_1 carton.n.02_1) \n        (inside notebook.n.01_1 carton.n.02_1) \n        (inroom floor.n.01_1 living_room) \n        (inroom sofa.n.01_1 living_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (onfloor ?carton.n.02_1 ?floor.n.01_1) \n            (forall \n                (?sock.n.01 - sock.n.01) \n                (ontop ?sock.n.01 ?sofa.n.01_1)\n            ) \n            (ontop ?perfume.n.02_1 ?sofa.n.01_1) \n            (ontop ?toothbrush.n.01_1 ?sofa.n.01_1) \n            (ontop ?notebook.n.01_1 ?sofa.n.01_1)\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_ontop)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "vacuuming_floors_0_Ihlen_1_int_0_2021-06-08_18-03-55",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem vacuuming_floors_0)\n    (:domain igibson)\n\n    (:objects\n     \tfloor.n.01_1 - floor.n.01\n    \tvacuum.n.04_1 - vacuum.n.04\n        ashcan.n.01_1 - ashcan.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (onfloor vacuum.n.04_1 floor.n.01_1) \n        (onfloor ashcan.n.01_1 floor.n.01_1) \n        (inroom floor.n.01_1 bedroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_vacuum)\n:parameters (?vacuum - vacuum.n.04 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "washing_cars_or_other_vehicles_0_Ihlen_0_int_0_2021-10-25_22-38-10",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem washing_cars_or_other_vehicles_0)\n    (:domain igibson)\n\n    (:objects\n     \tsoap.n.01_1 - soap.n.01\n    \tcar.n.01_1 - car.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tbucket.n.01_1 - bucket.n.01\n    \trag.n.01_1 - rag.n.01\n    \tagent.n.01_1 - agent.n.01\n        sink.n.01_1 - sink.n.01\n    )\n    \n    (:init \n        (ontop soap.n.01_1 car.n.01_1) \n        (onfloor car.n.01_1 floor.n.01_1) \n        (ontop bucket.n.01_1 car.n.01_1) \n        (ontop rag.n.01_1 car.n.01_1) \n        (dusty car.n.01_1) \n        (stained car.n.01_1) \n        (inroom floor.n.01_1 garage) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty car.n.01_1)\n            ) \n            (not \n                (stained car.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "washing_dishes_0_Benevolence_1_int_0_2021-06-08_18-07-48",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem washing_dishes_0)\n    (:domain igibson)\n\n    (:objects\n     \tplate.n.04_1 plate.n.04_2 - plate.n.04\n        cup.n.01_1 - cup.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tbowl.n.01_1 - bowl.n.01\n    \tfloor.n.01_1 - floor.n.01\n        countertop.n.01_1 - countertop.n.01\n        scrub_brush.n.01_1 - scrub_brush.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop plate.n.04_1 countertop.n.01_1) \n        (ontop plate.n.04_2 countertop.n.01_1) \n        (ontop bowl.n.01_1 countertop.n.01_1) \n        (ontop cup.n.01_1 countertop.n.01_1) \n        (inside scrub_brush.n.01_1 sink.n.01_1) \n        (stained plate.n.04_1) \n        (stained plate.n.04_2) \n        (stained cup.n.01_1) \n        (stained bowl.n.01_1) \n        (inroom sink.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?plate.n.04 - plate.n.04) \n                (not \n                    (stained ?plate.n.04)\n                )\n            ) \n            (not \n                (stained ?cup.n.01_1)\n            ) \n            (not \n                (stained ?bowl.n.01_1)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "washing_floor_0_Ihlen_1_int_1_2021-10-26_14-53-28",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem washing_floor_0)\n    (:domain igibson)\n\n    (:objects\n     \tbucket.n.01_1 - bucket.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \ttowel.n.01_1 - towel.n.01\n    \tshower.n.01_1 - shower.n.01\n    \ttoilet.n.02_1 - toilet.n.02\n    \tbed.n.01_1 - bed.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor bucket.n.01_1 floor.n.01_1) \n        (ontop soap.n.01_1 towel.n.01_1) \n        (onfloor soap.n.01_1 floor.n.01_1) \n        (onfloor towel.n.01_1 floor.n.01_1) \n        (not \n            (stained towel.n.01_1)\n        ) \n        (dusty floor.n.01_1) \n        (stained floor.n.01_1) \n        (inroom floor.n.01_1 bathroom) \n        (inroom shower.n.01_1 bathroom) \n        (inroom toilet.n.02_1 bathroom) \n        (inroom bed.n.01_1 bedroom) \n        (inroom sink.n.01_1 bathroom) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (or \n                    (dusty ?floor.n.01_1) \n                    (stained ?floor.n.01_1)\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "washing_pots_and_pans_0_Pomaria_1_int_0_2021-10-26_13-06-44",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem washing_pots_and_pans_0)\n    (:domain igibson)\n\n    (:objects\n     \tteapot.n.01_1 - teapot.n.01\n        kettle.n.01_1 - kettle.n.01\n    \tpan.n.01_1 pan.n.01_2 pan.n.01_3 - pan.n.01\n    \tcountertop.n.01_1 countertop.n.01_2 - countertop.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tscrub_brush.n.01_1 - scrub_brush.n.01\n    \tsoap.n.01_1 - soap.n.01\n    \tcabinet.n.01_1 cabinet.n.01_2 - cabinet.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (ontop teapot.n.01_1 countertop.n.01_1) \n        (stained teapot.n.01_1) \n        (ontop kettle.n.01_1 countertop.n.01_2) \n        (stained kettle.n.01_1) \n        (ontop pan.n.01_1 countertop.n.01_1) \n        (stained pan.n.01_1) \n        (ontop pan.n.01_2 countertop.n.01_1) \n        (stained pan.n.01_2) \n        (ontop pan.n.01_3 countertop.n.01_2) \n        (stained pan.n.01_3) \n        (ontop scrub_brush.n.01_1 countertop.n.01_2) \n        (soaked scrub_brush.n.01_1) \n        (inside soap.n.01_1 sink.n.01_1) \n        (inroom cabinet.n.01_1 kitchen) \n        (inroom cabinet.n.01_2 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom floor.n.01_1 kitchen) \n        (inroom countertop.n.01_2 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?pan.n.01 - pan.n.01) \n                (and \n                    (not \n                        (stained ?pan.n.01)\n                    ) \n                    (exists \n                        (?cabinet.n.01 - cabinet.n.01) \n                        (inside ?pan.n.01 ?cabinet.n.01)\n                    )\n                )\n            ) \n            (forall \n                (?kettle.n.01 - kettle.n.01) \n                (and \n                    (not \n                        (stained ?kettle.n.01)\n                    ) \n                    (exists \n                        (?cabinet.n.01 - cabinet.n.01) \n                        (inside ?kettle.n.01 ?cabinet.n.01)\n                    )\n                )\n            )\n            (forall \n                (?teapot.n.01 - teapot.n.01) \n                (and \n                    (not \n                        (stained ?teapot.n.01)\n                    ) \n                    (exists \n                        (?cabinet.n.01 - cabinet.n.01) \n                        (inside ?teapot.n.01 ?cabinet.n.01)\n                    )\n                )\n            )\n        )\n    )\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "watering_houseplants_0_Beechwood_0_int_0_2021-10-26_15-20-01",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem watering_houseplants_0)\n    (:domain igibson)\n\n    (:objects\n     \tpot_plant.n.01_1 pot_plant.n.01_2 pot_plant.n.01_3 - pot_plant.n.01\n    \tfloor.n.01_1 floor.n.01_2 - floor.n.01\n    \tsink.n.01_1 - sink.n.01\n    \ttable.n.02_1 - table.n.02\n    \tcountertop.n.01_1 - countertop.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor pot_plant.n.01_1 floor.n.01_1) \n        (onfloor pot_plant.n.01_2 floor.n.01_1) \n        (onfloor pot_plant.n.01_3 floor.n.01_2) \n        (not \n            (soaked pot_plant.n.01_1)\n        ) \n        (not \n            (soaked pot_plant.n.01_2)\n        ) \n        (not \n            (soaked pot_plant.n.01_3)\n        ) \n        (inroom table.n.02_1 dining_room) \n        (inroom floor.n.01_1 dining_room) \n        (inroom floor.n.01_2 kitchen) \n        (inroom countertop.n.01_1 kitchen) \n        (inroom sink.n.01_1 kitchen) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (forall \n                (?pot_plant.n.01 - pot_plant.n.01) \n                (soaked ?pot_plant.n.01)\n            )\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj2 - object ?agent - agent.n.01 ?obj1 - object)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?agent - agent.n.01 ?sink - sink.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    },
    {
        "identifier": "waxing_cars_or_other_vehicles_0_Ihlen_0_int_0_2021-10-25_23-03-46",
        "llm_prompt": "\nYou are a software engineer who will be writing action definitions for a household robot in the PDDL planning language given the problem file and predicates in domain file.\n\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson-actions)\n(:requirements :strips :adl :typing :negative-preconditions)\n    ;; types in virtualhome domain\n    (:types \n        facsimile.n.02 vacuum.n.04 dishtowel.n.01 apparel.n.01 seat.n.03 bottle.n.01 mouse.n.04 window.n.01 scanner.n.02 \n        sauce.n.01 spoon.n.01 date.n.08 egg.n.02 cabinet.n.01 yogurt.n.01 parsley.n.02 notebook.n.01 dryer.n.01 saucepan.n.01 \n        soap.n.01 package.n.02 headset.n.01 fish.n.02 vehicle.n.01 chestnut.n.03 grape.n.01 wrapping.n.01 makeup.n.01 mug.n.04 \n        pasta.n.02 beef.n.02 scrub_brush.n.01 cracker.n.01 flour.n.01 sunglass.n.01 cookie.n.01 bed.n.01 lamp.n.02 food.n.02 \n        painting.n.01 carving_knife.n.01 pop.n.02 tea_bag.n.01 sheet.n.03 tomato.n.01 agent.n.01 hat.n.01 dish.n.01 cheese.n.01 \n        perfume.n.02 toilet.n.02 broccoli.n.02 book.n.02 towel.n.01 table.n.02 pencil.n.01 rag.n.01 peach.n.03 water.n.06 cup.n.01 \n        radish.n.01 marker.n.03 tile.n.01 box.n.01 screwdriver.n.01 raspberry.n.02 banana.n.02 grill.n.02 caldron.n.01 vegetable_oil.n.01 \n        necklace.n.01 brush.n.02 washer.n.03 hamburger.n.01 catsup.n.01 sandwich.n.01 plaything.n.01 candy.n.01 cereal.n.03 door.n.01 \n        food.n.01 newspaper.n.03 hanger.n.02 carrot.n.03 salad.n.01 toothpaste.n.01 blender.n.01 sofa.n.01 plywood.n.01 olive.n.04 briefcase.n.01 \n        christmas_tree.n.05 bowl.n.01 casserole.n.02 apple.n.01 basket.n.01 pot_plant.n.01 backpack.n.01 sushi.n.01 saw.n.02 toothbrush.n.01 \n        lemon.n.01 pad.n.01 receptacle.n.01 sink.n.01 countertop.n.01 melon.n.01 bracelet.n.02 modem.n.01 pan.n.01 oatmeal.n.01 calculator.n.02 \n        duffel_bag.n.01 sandal.n.01 floor.n.01 snack_food.n.01 stocking.n.01 dishwasher.n.01 pencil_box.n.01 chicken.n.01 jar.n.01 alarm.n.02 \n        stove.n.01 plate.n.04 highlighter.n.02 umbrella.n.01 piece_of_cloth.n.01 bin.n.01 ribbon.n.01 chip.n.04 shelf.n.01 bucket.n.01 shampoo.n.01 \n        folder.n.02 shoe.n.01 detergent.n.02 milk.n.01 beer.n.01 shirt.n.01 dustpan.n.02 cube.n.05 broom.n.01 candle.n.01 pen.n.01 microwave.n.02 \n        knife.n.01 wreath.n.01 car.n.01 soup.n.01 sweater.n.01 tray.n.01 juice.n.01 underwear.n.01 orange.n.01 envelope.n.01 fork.n.01 lettuce.n.03 \n        bathtub.n.01 earphone.n.01 pool.n.01 printer.n.03 sack.n.01 highchair.n.01 cleansing_agent.n.01 kettle.n.01 vidalia_onion.n.01 mousetrap.n.01 \n        bread.n.01 meat.n.01 mushroom.n.05 cake.n.03 vessel.n.03 bow.n.08 gym_shoe.n.01 hammer.n.02 teapot.n.01 chair.n.01 jewelry.n.01 pumpkin.n.02 sugar.n.01 \n        shower.n.01 ashcan.n.01 hand_towel.n.01 pork.n.01 strawberry.n.01 electric_refrigerator.n.01 oven.n.01 ball.n.01 document.n.01 sock.n.01 beverage.n.01 \n        hardback.n.01 scraper.n.01 carton.n.02\n    )\n\n    ;; Predicates defined on this domain. Note the types for each predicate.\n    (:predicates\n        (inside ?obj1 ?obj2) ; obj1 is inside obj2\n        (nextto ?obj1 ?obj2) ; obj1 is next to obj2\n        (ontop ?obj1 ?obj2) ; obj1 is on top of obj2\n        (under ?obj1 ?obj2) ; obj1 is under obj2\n        (broken ?obj1) ; obj1 is broken\n        (burnt ?obj1) ; obj1 is burnt\n        (cooked ?obj1) ; obj1 is cooked\n        (dusty ?obj1) ; obj1 is dusty\n        (frozen ?obj1) ; obj1 is frozen\n        (open ?obj1) ; obj1 is open\n        (stained ?obj1) ; obj1 is stained\n        (sliced ?obj1) ; obj1 is sliced\n        (soaked ?obj1) ; obj1 is soaked\n        (toggled_on ?obj1) ; obj1 is toggled on\n        (onfloor ?obj1 ?floor1) ; obj1 is on the floor floor1\n        (touching ?obj1 ?obj2) ; obj1 is touching obj2\n        (holding ?obj1) ; obj1 is being held by agent\n        (handsfull ?agent) ; agent's hands are both full\n        )\n    ;; Actions to be predicted\n)\n\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \n\nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\n\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \n\nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\n\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\n\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\n\nHere is an example of the input problem file and unfinished action. after ; is a comment to explain the meaning of each line.\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor.n.01_1 - floor.n.01\n    \trag.n.01_1 - rag.n.01\n    \tsink.n.01_1 - sink.n.01\n    \tagent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (dusty floor.n.01_1) \n        (stained floor.n.01_2) \n        (ontop rag.n.01_1 table.n.02_1) \n        (inroom sink.n.01_1 storage_room) \n        (onfloor agent.n.01_1 floor.n.01_2)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?floor.n.01_1)\n            ) \n            (not \n                (stained ?floor.n.01_2)\n            ) \n        )\n    )\n)\nAction to be finished:\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition ()\n  :effect ()\n)\nOutput: \n(:action clean-stained-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (soaked ?rag) ; rag is soaked\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (stained ?floor)) ; after the action, floor is not stained\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag.n.01 ?floor - floor.n.01 ?agent - agent.n.01)\n  :precondition (and (nextto ?floor ?agent) ; agent is next to floor\n                            (stained ?obj) ; floor is stained\n                            (holding ?rag)) ; agent is holding rag\n  :effect (not (dusty ?floor)) ; after the action, floor is not dusty\n)\n(:action soak-rag\n  :parameters (?rag - rag.n.01 ?agent - agent.n.01 ?sink - sink.n.01)\n  :precondition  (and (holding ?rag) ; agent is holding rag\n                            (nextto ?sink ?agent) ; agent is next to sink\n                            (toggled_on ?sink)) ; sink is toggled on\n  :effect (soaked ?rag) ; after the action, rag is soaked\n)\n\nAbove is a good example of given predicates in domain file, problem file, action names and parameters, how to write the action body in PDDL. REMEMBER: You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \n\nInput:\nProblem file:\n(define (problem waxing_cars_or_other_vehicles_0)\n    (:domain igibson)\n\n    (:objects\n     \tvehicle.n.01_1 - vehicle.n.01\n    \tfloor.n.01_1 - floor.n.01\n    \tvessel.n.03_1 - vessel.n.03\n    \tshelf.n.01_1 - shelf.n.01\n\trag.n.01_1 - rag.n.01\n        agent.n.01_1 - agent.n.01\n    )\n    \n    (:init \n        (onfloor vehicle.n.01_1 floor.n.01_1) \n        (dusty vehicle.n.01_1) \n        (ontop vessel.n.03_1 shelf.n.01_1) \n\t(inside rag.n.01_1 shelf.n.01_1)\n        (inroom floor.n.01_1 garage) \n        (inroom shelf.n.01_1 garage) \n        (onfloor agent.n.01_1 floor.n.01_1)\n    )\n    \n    (:goal \n        (and \n            (not \n                (dusty ?vehicle.n.01_1)\n            ) \n        )\n    )\n)\n\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag.n.01 ?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent.n.01)\n:precondition ()\n:effect ()\n)\n\n\nOutput:\n"
    }
]